
# File: .gitignore
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
/public/workbox*.*
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
favicon.ico


# File: components.json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": false,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/app/globals.css",
    "baseColor": "stone",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

# File: eslint.config.mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [...compat.extends("next/core-web-vitals")];

export default eslintConfig;


# File: jsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}


# File: next.config.cjs
// next.config.js (version 2.9)
const withPWA = require("@ducanh2912/next-pwa").default({
  dest: "public",
});

/** @type {import('next').NextConfig} */
const nextConfig = {
  // All Webpack configurations are removed as they are unnecessary.
  // The problem is solved at the file system level by patching the dependency.
};

module.exports = withPWA(nextConfig);

# File: next.config.js
// next.config.js (version 1.7)
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true,
  // The 'disable' flag is removed to enable PWA features in development.
  // We revert to `customWorkerDir`, which is the correct property for next-pwa@5.6.0.
  customWorkerDir: 'worker', 
});

/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true,
  },
  
  webpack: (config, { isServer }) => {
    if (isServer) {
      config.externals = [...config.externals, 'onnxruntime-node'];
    }
    return config;
  },
};

module.exports = withPWA(nextConfig);

# File: package.json
{
  "name": "headlines-client",
  "version": "0.3.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@mozilla/readability": "^0.5.0",
    "@pinecone-database/pinecone": "^2.2.2",
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-alert-dialog": "^1.0.5",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@tailwindcss/typography": "^0.5.13",
    "@xenova/transformers": "^2.17.2",
    "ai": "^3.1.27",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "jsdom": "^24.1.0",
    "lucide-react": "^0.379.0",
    "mongoose": "^8.4.0",
    "next": "13.5.6",
    "next-pwa": "^5.6.0",
    "next-themes": "^0.4.6",
    "openai": "^4.47.3",
    "pusher-js": "^8.4.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-intersection-observer": "^9.16.0",
    "react-markdown": "^9.0.1",
    "react-textarea-autosize": "^8.5.3",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.0",
    "remove-markdown": "^0.5.0",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.3.0",
    "tailwindcss-animate": "^1.0.7",
    "web-push": "^3.6.7",
    "wikijs": "^6.4.1",
    "zod": "^3.23.8",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.19",
    "eslint": "^8",
    "eslint-config-next": "13.5.6",
    "postcss": "^8",
    "tailwindcss": "^3.4.1"
  }
}

# File: postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

# File: public/manifest.json
{
  "name": "Headlines Intelligence",
  "short_name": "Headlines",
  "description": "An interface to browse, search, and filter wealth event articles.",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#111827",
  "theme_color": "#111827",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}

# File: public/sw.js
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  let registry = {};

  // Used for `eval` and `importScripts` where we can't get script URL by other means.
  // In both cases, it's safe to use a global var because those functions are synchronous.
  let nextDefineUri;

  const singleRequire = (uri, parentUri) => {
    uri = new URL(uri + ".js", parentUri).href;
    return registry[uri] || (
      
        new Promise(resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            script.src = uri;
            script.onload = resolve;
            document.head.appendChild(script);
          } else {
            nextDefineUri = uri;
            importScripts(uri);
            resolve();
          }
        })
      
      .then(() => {
        let promise = registry[uri];
        if (!promise) {
          throw new Error(`Module ${uri} didn’t register its module`);
        }
        return promise;
      })
    );
  };

  self.define = (depsNames, factory) => {
    const uri = nextDefineUri || ("document" in self ? document.currentScript.src : "") || location.href;
    if (registry[uri]) {
      // Module is already loading or loaded.
      return;
    }
    let exports = {};
    const require = depUri => singleRequire(depUri, uri);
    const specialDeps = {
      module: { uri },
      exports,
      require
    };
    registry[uri] = Promise.all(depsNames.map(
      depName => specialDeps[depName] || require(depName)
    )).then(deps => {
      factory(...deps);
      return exports;
    });
  };
}
define(['./workbox-e43f5367'], (function (workbox) { 'use strict';

  importScripts("worker-development.js");
  self.skipWaiting();
  workbox.clientsClaim();
  workbox.registerRoute("/", new workbox.NetworkFirst({
    "cacheName": "start-url",
    plugins: [{
      cacheWillUpdate: async ({
        request,
        response,
        event,
        state
      }) => {
        if (response && response.type === 'opaqueredirect') {
          return new Response(response.body, {
            status: 200,
            statusText: 'OK',
            headers: response.headers
          });
        }
        return response;
      }
    }]
  }), 'GET');
  workbox.registerRoute(/.*/i, new workbox.NetworkOnly({
    "cacheName": "dev",
    plugins: []
  }), 'GET');

}));
//# sourceMappingURL=sw.js.map


# File: public/sw.js.map
{"version":3,"file":"sw.js","sources":["../../../../../tmp/bb3ea485d3ee21564d20d76e53c1f751/sw.js"],"sourcesContent":["import {registerRoute as workbox_routing_registerRoute} from '/home/mark/Repos/projects/headlines-client/node_modules/workbox-routing/registerRoute.mjs';\nimport {NetworkFirst as workbox_strategies_NetworkFirst} from '/home/mark/Repos/projects/headlines-client/node_modules/workbox-strategies/NetworkFirst.mjs';\nimport {NetworkOnly as workbox_strategies_NetworkOnly} from '/home/mark/Repos/projects/headlines-client/node_modules/workbox-strategies/NetworkOnly.mjs';\nimport {clientsClaim as workbox_core_clientsClaim} from '/home/mark/Repos/projects/headlines-client/node_modules/workbox-core/clientsClaim.mjs';/**\n * Welcome to your Workbox-powered service worker!\n *\n * You'll need to register this file in your web app.\n * See https://goo.gl/nhQhGp\n *\n * The rest of the code is auto-generated. Please don't update this file\n * directly; instead, make changes to your Workbox build configuration\n * and re-run your build process.\n * See https://goo.gl/2aRDsh\n */\n\n\nimportScripts(\n  \"worker-development.js\"\n);\n\n\n\n\n\n\n\nself.skipWaiting();\n\nworkbox_core_clientsClaim();\n\n\n\nworkbox_routing_registerRoute(\"/\", new workbox_strategies_NetworkFirst({ \"cacheName\":\"start-url\", plugins: [{ cacheWillUpdate: async ({ request, response, event, state }) => { if (response && response.type === 'opaqueredirect') { return new Response(response.body, { status: 200, statusText: 'OK', headers: response.headers }) } return response } }] }), 'GET');\nworkbox_routing_registerRoute(/.*/i, new workbox_strategies_NetworkOnly({ \"cacheName\":\"dev\", plugins: [] }), 'GET');\n\n\n\n\n"],"names":["importScripts","self","skipWaiting","workbox_core_clientsClaim","workbox_routing_registerRoute","workbox_strategies_NetworkFirst","plugins","cacheWillUpdate","request","response","event","state","type","Response","body","status","statusText","headers","workbox_strategies_NetworkOnly"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgBAA,CAAa,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CACX,CACF,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAC,CAAA;EAQDC,CAAI,CAAA,CAAA,CAAA,CAACC,CAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAE,CAAA;AAElBC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAyB,EAAE,CAAA;AAI3BC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAA6B,CAAC,CAAA,CAAA,CAAG,CAAE,CAAA,CAAA,CAAA,CAAA,CAAIC,oBAA+B,CAAC,CAAA;EAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAW,EAAC,CAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;EAAEC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAO,EAAE,CAAC,CAAA;GAAEC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAe,EAAE,CAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAEC,CAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAEC,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAEC,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA;AAAEC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA;AAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAC,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA;EAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAIF,QAAQ,CAAIA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAQ,CAACG,CAAI,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAK,gBAAgB,CAAE,CAAA,CAAA;AAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,OAAO,CAAIC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAQ,CAACJ,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAACK,IAAI,CAAE,CAAA,CAAA;EAAEC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAM,EAAE,CAAG,CAAA,CAAA,CAAA;EAAEC,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAU,EAAE,CAAI,CAAA,CAAA,CAAA,CAAA;YAAEC,CAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAER,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAACQ,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA;AAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAC,CAAC,CAAA;EAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;EAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAOR,QAAQ,CAAA;EAAC,CAAA,CAAA,CAAA,CAAA,CAAA;KAAG,CAAA;AAAE,CAAA,CAAA,CAAC,CAAC,CAAA,CAAE,CAAK,CAAA,CAAA,CAAA,CAAA,CAAC,CAAA;AACxWL,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAA6B,CAAC,CAAA,CAAA,CAAA,CAAA,CAAK,CAAE,CAAA,CAAA,CAAA,CAAA,CAAIc,mBAA8B,CAAC,CAAA;EAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAW,EAAC,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA;EAAEZ,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAO,EAAE,CAAA,CAAA;EAAG,CAAC,CAAC,CAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAK,CAAC,CAAA;;"}

# File: public/worker-development.js
/******/ (() => { // webpackBootstrap
var __webpack_exports__ = {};
// worker/index.js (version 1.2)
// The invalid `"use client";` directive has been removed.

self.addEventListener('push', event => {
  console.log('[Service Worker] Push Received.');
  console.log(`[Service Worker] Push had this data: "${event.data.text()}"`);
  let data;
  try {
    data = event.data.json();
  } catch (e) {
    console.error('[Service Worker] Failed to parse push data as JSON.');
    data = {
      title: 'New Update',
      body: event.data.text(),
      url: '/'
    };
  }
  const title = data.title || 'New Intelligence Alert';
  const options = {
    body: data.body || 'New content has been added.',
    icon: data.icon || '/icons/icon-192x192.png',
    badge: '/icons/icon-96x96.png',
    vibrate: [100, 50, 100],
    data: {
      url: data.url || '/'
    }
  };
  event.waitUntil(self.registration.showNotification(title, options));
});
self.addEventListener('notificationclick', event => {
  console.log('[Service Worker] Notification click Received.');
  event.notification.close();
  const urlToOpen = new URL(event.notification.data.url, self.location.origin).href;
  event.waitUntil(self.clients.matchAll({
    type: 'window',
    includeUncontrolled: true
  }).then(clientList => {
    if (clientList.length > 0) {
      let client = clientList[0];
      for (let i = 0; i < clientList.length; i++) {
        if (clientList[i].focused) {
          client = clientList[i];
        }
      }
      return client.focus().then(c => c.navigate(urlToOpen));
    }
    return self.clients.openWindow(urlToOpen);
  }));
});
/******/ })()
;

# File: scripts/patch-transformers.js
// scripts/patch-transformers.js (version 2.0)
const fs = require('fs');
const path = require('path');

// The known-good, browser-only content for the env.js file.
const overrideContent = `
// This file is a build-time override for the environment detection in @xenova/transformers.
// It forces the library to believe it is running in a browser environment,
// which prevents Webpack from attempting to bundle the native \`onnxruntime-node\` module.
export const env = {
    isBrowser: true,
    isNode: false,
    isWebWorker: false,
    remoteModels: true,
    remoteHost: 'https://huggingface.co/',
    remotePathTemplate: '{model}/resolve/{revision}/',
    localModels: false,
    localModelPath: '/models/',
    useCache: true,
    useWebGPU: false,
    useSimd: false,
};
`;

const envPath = path.join(
  __dirname,
  '..',
  'node_modules',
  '@xenova',
  'transformers',
  'src',
  'env.js'
);

try {
  if (fs.existsSync(envPath)) {
    console.log('[Patch] Found @xenova/transformers/src/env.js. Overwriting...');
    // Physically overwrite the entire file with our safe, browser-only version.
    fs.writeFileSync(envPath, overrideContent.trim(), 'utf8');
    console.log('[Patch] Successfully overwrote env.js to prevent onnxruntime-node import.');
  } else {
    console.warn('[Patch] Could not find @xenova/transformers/src/env.js to patch. The build may fail.');
  }
} catch (error) {
  console.error('[Patch] An error occurred during the patching process:', error);
  process.exit(1);
}

# File: src/actions/articles.js
// src/actions/articles.js (version 1.1)
"use server";

import dbConnect from "@/lib/mongodb";
import Article from "@/models/Article";
import { revalidatePath } from "next/cache";
import { ARTICLES_PER_PAGE } from "@/config/constants";

export async function deleteArticle(articleId) {
  if (!articleId) {
    return { success: false, message: "Article ID is required." };
  }

  try {
    await dbConnect();
    const result = await Article.findByIdAndDelete(articleId);

    if (!result) {
      return { success: false, message: "Article not found." };
    }

    revalidatePath("/");
    return { success: true, message: "Article deleted successfully." };

  } catch (error) {
    console.error("Delete Article Error:", error);
    return { success: false, message: "Failed to delete article." };
  }
}

export async function getArticles({ page = 1, filters = {}, sort = 'date_desc' }) {
    await dbConnect();

    const queryFilter = {
        $or: [
            { relevance_article: { $gt: 25 } },
            { relevance_headline: { $gt: 25 } }
        ]
    };

    if (filters.q) {
        const searchRegex = { $regex: filters.q, $options: 'i' };
        queryFilter.$or.push(
            { headline: searchRegex },
            { headline_en: searchRegex },
            { assessment_article: searchRegex },
            { 'key_individuals.name': searchRegex }
        );
    }
    if (filters.country) {
        queryFilter.country = filters.country;
    }

    const sortOptions = {};
    if (sort === 'date_asc') sortOptions.createdAt = 1;
    else if (sort === 'relevance_desc') sortOptions.relevance_article = -1;
    else sortOptions.createdAt = -1;

    const skipAmount = (page - 1) * ARTICLES_PER_PAGE;

    const articles = await Article.find(queryFilter)
        .sort(sortOptions)
        .skip(skipAmount)
        .limit(ARTICLES_PER_PAGE)
        .lean();
    
    return JSON.parse(JSON.stringify(articles));
}

# File: src/actions/chat.js
// src/actions/chat.js (version 1.0)
"use server";

import OpenAI from 'openai';

if (!process.env.GROQ_API_KEY) {
    throw new Error('GROQ API Key is missing');
}
const groq = new OpenAI({ apiKey: process.env.GROQ_API_KEY, baseURL: 'https://api.groq.com/openai/v1' });

const TITLE_GENERATOR_MODEL = 'llama3-8b-8192';

const TITLE_GENERATOR_PROMPT = `You are a title generation AI. Your task is to read a conversation and create a concise, 5-word-or-less title that accurately summarizes the main topic.
- Be direct and factual.
- Do not use quotes or introductory phrases.
- The title should be in the same language as the conversation.

Example Conversation:
"user: Who is Anders Holch Povlsen?
assistant: Anders Holch Povlsen is a Danish billionaire, the CEO and sole owner of the international fashion retailer Bestseller."

Example Title:
"Anders Holch Povlsen's Bestseller"`;

/**
 * Generates a concise title for a chat conversation.
 * @param {Array<{role: string, content: string}>} messages - The chat messages.
 * @returns {Promise<{success: boolean, title?: string, error?: string}>}
 */
export async function generateChatTitle(messages) {
    if (!messages || messages.length < 2) {
        return { success: false, error: 'Not enough messages to generate a title.' };
    }

    try {
        const conversationText = messages.map(m => `${m.role}: ${m.content}`).join('\n');

        const response = await groq.chat.completions.create({
            model: TITLE_GENERATOR_MODEL,
            messages: [
                { role: 'system', content: TITLE_GENERATOR_PROMPT },
                { role: 'user', content: conversationText }
            ],
            temperature: 0.1,
        });

        const title = response.choices[0].message.content.trim().replace(/"/g, '');
        return { success: true, title };

    } catch (error) {
        console.error("Chat Title Generation Error:", error);
        return { success: false, error: "Failed to generate title." };
    }
}

# File: src/actions/events.js
// src/actions/events.js (version 1.1)
"use server";

import dbConnect from "@/lib/mongodb";
import SynthesizedEvent from "@/models/SynthesizedEvent";
import { revalidatePath } from "next/cache";
import { EVENTS_PER_PAGE } from "@/config/constants";

export async function deleteEvent(eventId) {
  if (!eventId) {
    return { success: false, message: "Event ID is required." };
  }

  try {
    await dbConnect();
    const result = await SynthesizedEvent.findByIdAndDelete(eventId);

    if (!result) {
      return { success: false, message: "Synthesized event not found." };
    }

    revalidatePath("/");
    return { success: true, message: "Synthesized event deleted successfully." };

  } catch (error) {
    console.error("Delete Event Error:", error);
    return { success: false, message: "Failed to delete synthesized event." };
  }
}

export async function getEvents({ page = 1, filters = {}, sort = 'date_desc' }) {
    await dbConnect();

    const queryFilter = {
        highest_relevance_score: { $gt: 25 }
    };

    if (filters.q) {
        const searchRegex = { $regex: filters.q, $options: 'i' };
        queryFilter.$or = [
            { synthesized_headline: searchRegex },
            { synthesized_summary: searchRegex },
            { 'key_individuals.name': searchRegex },
        ];
    }
    if (filters.country) {
        queryFilter.country = filters.country;
    }
    
    const sortOptions = {};
    if (sort === 'date_asc') sortOptions.createdAt = 1;
    else if (sort === 'relevance_desc') sortOptions.highest_relevance_score = -1;
    else sortOptions.createdAt = -1;

    const skipAmount = (page - 1) * EVENTS_PER_PAGE;

    const events = await SynthesizedEvent.find(queryFilter)
        .sort(sortOptions)
        .skip(skipAmount)
        .limit(EVENTS_PER_PAGE)
        .lean();
    
    return JSON.parse(JSON.stringify(events));
}

# File: src/actions/extract.js
"use server";

import OpenAI from 'openai';
import { JSDOM } from 'jsdom';
import { Readability } from '@mozilla/readability';
import { COMMON_COUNTRIES } from '@/lib/countries';
import { fetchWikipediaSummary } from '@/lib/wikipedia';

// Initialize GROQ Client
if (!process.env.GROQ_API_KEY) {
    throw new Error('GROQ API Key is missing');
}
const groq = new OpenAI({ apiKey: process.env.GROQ_API_KEY, baseURL: 'https://api.groq.com/openai/v1' });

// --- Models ---
const QUERY_PLANNER_MODEL = 'openai/gpt-oss-20b';
const ANALYST_MODEL = 'openai/gpt-oss-120b';

// --- Agent Prompts ---
const QUERY_PLANNER_PROMPT = `You are a research planning agent. Your task is to analyze the provided "Article Text" and determine the most critical entities to look up on Wikipedia for factual verification and enrichment.

**Instructions:**
1.  Identify the primary subject of the article (a person or a company).
2.  Determine the 1-2 most important, specific proper nouns for which a Wikipedia search would provide essential background context.
3.  Formulate these as precise, high-quality search queries.

Respond ONLY with a valid JSON object with the following structure:
{
  "reasoning": "A brief, one-sentence explanation of your decision-making process.",
  "wikipedia_queries": ["Precise Search Query 1", "Precise Search Query 2"]
}`;

const FINAL_SYNTHESIS_PROMPT = `You are a senior analyst at a top-tier wealth management firm. Your task is to synthesize a business-critical summary from the provided "Article Text", fact-checking and enriching it with the "Wikipedia Context".

**Your Mandate:**
1.  **Prioritize the Article:** The main story and facts must come from the "Article Text".
2.  **Use Wikipedia for Verification & Enrichment:** Use the "Wikipedia Context" to verify names, roles, and foundational facts (like founding dates or parent companies). Add relevant background details from Wikipedia that add value.
3.  **AGGRESSIVELY DISCARD FLUFF:** You MUST ignore all generic marketing language, mission statements, and other non-factual embellishments. Focus only on tangible, factual intelligence (company names, investment relationships, key individuals, strategic moves).
4.  **Deduce Metadata:** Determine the publication name and the primary country of relevance.

Respond ONLY with a valid JSON object with the following structure:
{
  "headline": "A concise, factual headline for the synthesized summary.",
  "publication": "The name of the newspaper or website.",
  "country": "The country this news is about. Choose one from this list: [${COMMON_COUNTRIES.join(', ')}].",
  "business_summary": "The final, synthesized, fact-checked summary, formatted with Markdown."
}`;

/**
 * Uses an AI Analyst Agent to extract business-savvy information from a URL.
 * @param {string} url The URL to scrape.
 * @returns {Promise<{success: boolean, data?: object, error?: string}>}
 */
export async function scrapeAndExtractWithAI(url) {
    if (!url) {
        return { success: false, error: "URL is required." };
    }

    try {
        // Step 1: Fetch and extract base text with Readability
        const response = await fetch(url, { headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36' } });
        if (!response.ok) return { success: false, error: `Fetch failed: ${response.status}` };
        
        const html = await response.text();
        const doc = new JSDOM(html, { url });
        const article = new Readability(doc.window.document).parse();
        if (!article || !article.textContent) return { success: false, error: "Readability could not extract content." };
        
        const articleText = article.textContent.trim().substring(0, 12000);

        // Step 2: AI Query Planning Agent decides what to search for
        const plannerResponse = await groq.chat.completions.create({
            model: QUERY_PLANNER_MODEL,
            messages: [
                { role: 'system', content: QUERY_PLANNER_PROMPT },
                { role: 'user', content: `Article Text:\n${articleText}` }
            ],
            response_format: { type: 'json_object' },
        });
        const plan = JSON.parse(plannerResponse.choices[0].message.content);
        
        // Step 3: Fetch Wikipedia context for the planned entities
        const wikipediaPromises = (plan.wikipedia_queries || []).slice(0, 2).map(entity => fetchWikipediaSummary(entity));
        const wikipediaResults = await Promise.all(wikipediaPromises);
        const wikipediaContext = wikipediaResults
            .filter(res => res.success)
            .map(res => res.summary)
            .join('\n\n---\n\n');

        // Step 4: AI Analyst Agent performs the final synthesis
        const finalAnalysis = await groq.chat.completions.create({
            model: ANALYST_MODEL,
            messages: [
                { role: 'system', content: FINAL_SYNTHESIS_PROMPT },
                { role: 'user', content: `URL: ${url}\n\n---ARTICLE TEXT---\n${articleText}\n\n---WIKIPEDIA CONTEXT---\n${wikipediaContext || 'None'}` }
            ],
            response_format: { type: 'json_object' },
        });

        const finalData = JSON.parse(finalAnalysis.choices[0].message.content);

        if (!finalData.headline || !finalData.business_summary) {
            return { success: false, error: "AI Analyst could not reliably synthesize a summary." };
        }

        return { success: true, data: finalData };

    } catch (error) {
        console.error("AI Extraction Error:", error);
        return { success: false, error: `An unexpected error occurred: ${error.message}` };
    }
}

# File: src/actions/knowledge.js
"use server";

import { revalidatePath } from "next/cache";
import { Pinecone } from '@pinecone-database/pinecone';
import mongoose from "mongoose";
import dbConnect from "@/lib/mongodb";
import Article from "@/models/Article";
import { generateEmbedding } from "@/lib/embeddings";

// Initialize Pinecone Client
if (!process.env.PINECONE_API_KEY) {
    throw new Error('Pinecone API Key must be defined in .env file');
}
const pc = new Pinecone({ apiKey: process.env.PINECONE_API_KEY });
const pineconeIndex = pc.index(process.env.PINECONE_INDEX_NAME || 'headlines');


/**
 * Saves a new piece of knowledge (article) to MongoDB and Pinecone.
 * @param {{headline: string, business_summary: string, source: string, country: string, link: string}} data
 * @returns {Promise<{success: boolean, message: string}>}
 */
export async function addKnowledge(data) {
    const { headline, business_summary, source, country, link } = data;

    if (!headline || !business_summary || !source || !country || !link) {
        return { success: false, message: "All fields are required." };
    }

    try {
        await dbConnect();

        // 1. Generate the embedding from the business-savvy summary
        const textToEmbed = `${headline}\n${business_summary}`;
        const embedding = await generateEmbedding(textToEmbed);

        // 2. Create the new Article document for MongoDB
        const newArticle = new Article({
            _id: new mongoose.Types.ObjectId(),
            headline,
            link,
            newspaper: source,
            source: "Manual Upload",
            country,
            relevance_headline: 100,
            assessment_headline: "Manually uploaded by user.",
            relevance_article: 100,
            assessment_article: business_summary, // Save the summary to the correct field
            embedding: embedding,
        });

        // 3. Save the structured data to MongoDB
        await newArticle.save();

        // 4. Upsert the vector and metadata to Pinecone
        await pineconeIndex.upsert([{
            id: newArticle._id.toString(),
            values: embedding,
            metadata: {
                headline: newArticle.headline,
                summary: newArticle.assessment_article,
                newspaper: newArticle.newspaper,
                country: newArticle.country
            }
        }]);

        // 5. Revalidate paths to update the UI
        revalidatePath("/articles");
        revalidatePath("/events");

        return { success: true, message: "Knowledge successfully added and embedded." };

    } catch (error) {
        console.error("Add Knowledge Error:", error);
        return { success: false, message: "Failed to add knowledge." };
    }
}

# File: src/actions/scrape.js
"use server";

import { Readability } from "@mozilla/readability";
import { JSDOM } from "jsdom";

/**
 * Scrapes a single URL using a standard fetch call and extracts its main article content.
 * This is a lightweight alternative to using a full browser like Playwright.
 * @param {string} url The URL to scrape.
 * @returns {Promise<{success: boolean, title?: string, content?: string, error?: string}>}
 */
export async function scrapeUrl(url) {
    if (!url) {
        return { success: false, error: "URL is required." };
    }

    try {
        const response = await fetch(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            }
        });

        if (!response.ok) {
            return { success: false, error: `Failed to fetch URL. Status: ${response.status}` };
        }

        const html = await response.text();
        const doc = new JSDOM(html, { url });
        const reader = new Readability(doc.window.document);
        const article = reader.parse();

        if (!article || !article.textContent) {
            return { success: false, error: "Could not extract main content from the page." };
        }

        return { success: true, title: article.title, content: article.textContent };

    } catch (error) {
        console.error("Scraping error:", error);
        return { success: false, error: `Failed to scrape URL: ${error.message}` };
    }
}

# File: src/app/(main)/articles/page.js
// src/app/(main)/articles/page.js (version 1.6)
import { Suspense } from 'react';
import { ArticlesView } from '@/components/ArticlesView';
import { GlobalFilters } from '@/components/GlobalFilters';
import { Header } from '@/components/Header';
import { MainNavTabs } from '@/components/MainNavTabs';
import { SkeletonCard } from '@/components/SkeletonCard';
import { ARTICLES_PER_PAGE } from '@/config/constants';
import dbConnect from '@/lib/mongodb';
import Article from '@/models/Article';
import SynthesizedEvent from '@/models/SynthesizedEvent';
import { getArticles } from '@/actions/articles';

async function getData(searchParams) {
    await dbConnect();
    const query = {
        country: { $ne: null },
        $or: [
            { relevance_article: { $gt: 25 } },
            { relevance_headline: { $gt: 25 } }
        ]
    };

    const uniqueCountriesPromise = Article.distinct('country', query);
    const articleCountPromise = Article.countDocuments(query);
    const eventCountPromise = SynthesizedEvent.countDocuments({ highest_relevance_score: { $gt: 25 } });
    
    const initialArticlesPromise = getArticles({ 
        page: 1, 
        filters: { q: searchParams.q, country: searchParams.country },
        sort: searchParams.sort 
    });

    const [uniqueCountries, articleCount, eventCount, initialArticles] = await Promise.all([
        uniqueCountriesPromise, articleCountPromise, eventCountPromise, initialArticlesPromise
    ]);
    return { uniqueCountries, articleCount, eventCount, initialArticles };
}

export default async function ArticlesPage({ searchParams }) {
    const { uniqueCountries, articleCount, eventCount, initialArticles } = await getData(searchParams);
    return (
        <div className="container mx-auto flex flex-col min-h-screen">
            <Header articleCount={articleCount} eventCount={eventCount} />
            <MainNavTabs />
            <main className="flex-grow flex flex-col mt-4 sm:mt-8">
                <GlobalFilters uniqueCountries={uniqueCountries} />
                <Suspense fallback={<SkeletonLoader count={ARTICLES_PER_PAGE} />}>
                    <ArticlesView 
                        initialArticles={initialArticles} 
                        searchParams={searchParams} 
                    />
                </Suspense>
            </main>
        </div>
    );
}

const SkeletonLoader = ({ count }) => (
    <div className="max-w-5xl mx-auto space-y-4">
        {Array.from({ length: count }).map((_, i) => <SkeletonCard key={i} />)}
    </div>
);

# File: src/app/(main)/chat/page.js
// src/app/(main)/chat/page.js (version 1.4)
import { ChatManager } from '@/components/ChatManager';
import { Header } from '@/components/Header';
import { MainNavTabs } from '@/components/MainNavTabs';

export default function ChatPage() {
    return (
        <div className="container mx-auto p-4 md:p-8 flex flex-col h-dvh overflow-hidden">
            <Header />
            <MainNavTabs />
            <main className="flex-grow flex flex-col mt-4 min-h-0">
                <ChatManager />
            </main>
        </div>
    );
}

# File: src/app/(main)/events/page.js
// src/app/(main)/events/page.js (version 1.6)
import { Suspense } from 'react';
import { EventsView } from '@/components/EventsView';
import { GlobalFilters } from '@/components/GlobalFilters';
import { Header } from '@/components/Header';
import { MainNavTabs } from '@/components/MainNavTabs';
import { SkeletonCard } from '@/components/SkeletonCard';
import { EVENTS_PER_PAGE } from '@/config/constants';
import dbConnect from '@/lib/mongodb';
import Article from '@/models/Article';
import SynthesizedEvent from '@/models/SynthesizedEvent';
import { getEvents } from '@/actions/events';

async function getData(searchParams) {
    await dbConnect();
    const uniqueCountriesPromise = SynthesizedEvent.distinct('country', { country: { $ne: null }, highest_relevance_score: { $gt: 25 } });
    const articleCountPromise = Article.countDocuments({ $or: [{relevance_article: { $gt: 25 }}, {relevance_headline: {$gt: 25}}] });
    const eventCountPromise = SynthesizedEvent.countDocuments({ highest_relevance_score: { $gt: 25 } });
    
    const initialEventsPromise = getEvents({ 
        page: 1, 
        filters: { q: searchParams.q, country: searchParams.country },
        sort: searchParams.sort
    });

    const [uniqueCountries, articleCount, eventCount, initialEvents] = await Promise.all([
        uniqueCountriesPromise, articleCountPromise, eventCountPromise, initialEventsPromise
    ]);
    return { uniqueCountries, articleCount, eventCount, initialEvents };
}

export default async function EventsPage({ searchParams }) {
    const { uniqueCountries, articleCount, eventCount, initialEvents } = await getData(searchParams);
    return (
        <div className="container mx-auto p-4 md:p-8 flex flex-col min-h-screen">
            <Header articleCount={articleCount} eventCount={eventCount} />
            <MainNavTabs />
            <main className="flex-grow flex flex-col mt-8">
                <GlobalFilters uniqueCountries={uniqueCountries} />
                <Suspense fallback={<SkeletonLoader count={EVENTS_PER_PAGE} />}>
                    <EventsView 
                        initialEvents={initialEvents}
                        searchParams={searchParams}
                    />
                </Suspense>
            </main>
        </div>
    );
}

const SkeletonLoader = ({ count }) => (
    <div className="max-w-5xl mx-auto space-y-4">
        {Array.from({ length: count }).map((_, i) => <SkeletonCard key={i} />)}
    </div>
);

# File: src/app/(main)/layout.js
// src/app/(main)/layout.js (version 1.7)
// This layout file is now empty and serves only to create the route group.
// All layout components are handled by individual pages for better control.
export default function MainLayout({ children }) {
    return <>{children}</>;
}

# File: src/app/(main)/page.js
import { redirect } from 'next/navigation';

/**
 * This is the default page for the root route ('/').
 * It immediately redirects the user to the '/events' view,
 * which is the default landing page for the application.
 */
export default function RootPage() {
  redirect('/events');
}

# File: src/app/(main)/upload/page.js
    
// src/app/(main)/upload/page.js (version 1.1)
import { UploadView } from '@/components/UploadView';
import { Header } from '@/components/Header';
import { MainNavTabs } from '@/components/MainNavTabs';

export default function UploadPage() {
    return (
        <div className="container mx-auto p-4 md:p-8 flex flex-col min-h-screen">
            <Header />
            <MainNavTabs />
            <main className="flex-grow flex flex-col mt-8">
                <UploadView />
            </main>
        </div>
    );
}

  



# File: src/app/api/analytics/route.js
// src/app/api/analytics/route.js - Analytics dashboard API
import { 
    getAnalyticsDashboard, 
    generateSystemRecommendations, 
    exportAnalytics,
    checkAlerts,
    cleanupAnalytics,
    identifyHallucinationRisks 
} from '@/lib/monitoring';

export async function GET(req) {
    try {
        const { searchParams } = new URL(req.url);
        const action = searchParams.get('action') || 'dashboard';
        const format = searchParams.get('format') || 'json';
        
        switch (action) {
            case 'dashboard':
                const dashboard = getAnalyticsDashboard();
                return Response.json(dashboard);
                
            case 'recommendations':
                const recommendations = generateSystemRecommendations();
                return Response.json({ recommendations });
                
            case 'alerts':
                const alerts = checkAlerts();
                return Response.json({ alerts, count: alerts.length });
                
            case 'risks':
                const risks = identifyHallucinationRisks();
                return Response.json({ risks });
                
            case 'export':
                const exportData = exportAnalytics(format);
                const headers = {
                    'Content-Type': format === 'csv' ? 'text/csv' : 'application/json',
                    'Content-Disposition': `attachment; filename="rag-analytics-${new Date().toISOString().split('T')[0]}.${format}"`
                };
                return new Response(exportData, { headers });
                
            case 'health':
                const healthData = {
                    status: 'healthy',
                    timestamp: new Date().toISOString(),
                    alerts: checkAlerts(),
                    uptime: process.uptime(),
                    memory: process.memoryUsage()
                };
                return Response.json(healthData);
                
            default:
                return Response.json({ error: 'Unknown action' }, { status: 400 });
        }
        
    } catch (error) {
        console.error('[Analytics API Error]', error);
        return Response.json({ error: 'Internal server error' }, { status: 500 });
    }
}

export async function POST(req) {
    try {
        const { action, ...params } = await req.json();
        
        switch (action) {
            case 'cleanup':
                const daysToKeep = params.daysToKeep || 30;
                const cleanupResult = cleanupAnalytics(daysToKeep);
                return Response.json({ 
                    message: 'Cleanup completed',
                    ...cleanupResult 
                });
                
            default:
                return Response.json({ error: 'Unknown action' }, { status: 400 });
        }
        
    } catch (error) {
        console.error('[Analytics API Error]', error);
        return Response.json({ error: 'Internal server error' }, { status: 500 });
    }
}

# File: src/app/api/chat/route.js
// src/app/api/chat/route.js (version 3.0)
import { processChatRequest } from '@/lib/rag/orchestrator';
import { logQuery, startTimer } from '@/lib/monitoring';

export async function POST(req) {
    const overallTimer = await startTimer('overall_request');
    let queryForLogging = 'unknown';

    try {
        const { messages } = await req.json();
        queryForLogging = messages[messages.length - 1].content;
        
        // Delegate all complex logic to the RAG orchestrator
        const response = await processChatRequest(messages);
        
        // The orchestrator returns a complete Response object (e.g., StreamingTextResponse)
        return response;

    } catch (error) {
        console.error('[CHAT API Top-Level Error]', error);
        
        const responseTime = await overallTimer.end({ error: true });
        
        // Log the failed query
        await logQuery({
            query: queryForLogging,
            responseTime,
            confidenceLevel: 'error',
            error: error.message
        });
        
        return new Response('An error occurred while processing your request. Please check the server logs for details.', { status: 500 });
    }
}

# File: src/app/api/push/subscribe/route.js
// src/app/api/push/subscribe/route.js (version 1.0)
import dbConnect from "@/lib/mongodb";
import PushSubscription from "@/models/PushSubscription";

export async function POST(req) {
    try {
        await dbConnect();
        const subscription = await req.json();

        if (!subscription || !subscription.endpoint) {
            return new Response(JSON.stringify({ error: "Invalid subscription object." }), { status: 400 });
        }

        // Use updateOne with upsert to avoid duplicate subscriptions
        await PushSubscription.updateOne(
            { endpoint: subscription.endpoint },
            { $set: subscription },
            { upsert: true }
        );

        return new Response(JSON.stringify({ success: true, message: "Subscription saved." }), { status: 201 });

    } catch (error) {
        console.error("Error saving push subscription:", error);
        return new Response(JSON.stringify({ error: "Failed to save subscription." }), { status: 500 });
    }
}

  

# File: src/app/globals.css
@import url('https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 224 71.4% 4.1%;
    --foreground: 210 40% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 40% 98%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 220.9 39.3% 11%;
    --secondary: 222.2 47.4% 11.2%;
    --secondary-foreground: 210 40% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --ring: 217 91% 60%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 224 71.4% 4.1%;
    --foreground: 210 40% 98%;
    --card: 224 71.4% 4.1%;
    --card-foreground: 210 40% 98%;
    --popover: 224 71.4% 4.1%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 220.9 39.3% 11%;
    --secondary: 222.2 47.4% 11.2%;
    --secondary-foreground: 210 40% 98%;
    --muted: 215 27.9% 16.9%;
    --muted-foreground: 217.9 10.6% 64.9%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 215 27.9% 16.9%;
    --input: 215 27.9% 16.9%;
    --ring: 217 91% 60%;
  }
  
  * {
    border-color: hsl(var(--border));
  }

  body {
    background-color: hsl(var(--background));
    color: hsl(var(--foreground));
    background-image: radial-gradient(
        at 27% 37%,
        hsla(215, 98%, 43%, 0.15) 0px,
        transparent 50%
      ),
      radial-gradient(
        at 97% 21%,
        hsla(217, 91%, 60%, 0.1) 0px,
        transparent 50%
      ),
      radial-gradient(
        at 52% 99%,
        hsla(355, 98%, 51%, 0.1) 0px,
        transparent 50%
      );
  }

  /* Professional Table Styling for Chat */
  .prose {
    --tw-prose-body: theme(colors.slate[300]);
    --tw-prose-headings: theme(colors.slate[100]);
    --tw-prose-lead: theme(colors.slate[400]);
    --tw-prose-links: theme(colors.blue[400]);
    --tw-prose-bold: theme(colors.slate[100]);
    --tw-prose-counters: theme(colors.slate[400]);
    --tw-prose-bullets: theme(colors.slate[600]);
    --tw-prose-hr: theme(colors.slate[700]);
    --tw-prose-quotes: theme(colors.slate[200]);
    --tw-prose-quote-borders: theme(colors.slate[700]);
    --tw-prose-captions: theme(colors.slate[400]);
    --tw-prose-code: theme(colors.slate[100]);
    --tw-prose-pre-code: theme(colors.slate[300]);
    --tw-prose-pre-bg: theme(colors.slate[900]);
    --tw-prose-th-borders: theme(colors.slate[600]);
    --tw-prose-td-borders: theme(colors.slate[700]);
  }

  .prose table {
    @apply text-sm;
  }
  .prose th {
    @apply text-slate-200 text-left px-3 py-2;
  }
  .prose td {
    @apply px-3 py-2 align-top;
  }
}

/* --- Premier Scrollbar Styling --- */
@layer utilities {
  .custom-scrollbar::-webkit-scrollbar {
    height: 6px;
    width: 6px;
  }
  .custom-scrollbar::-webkit-scrollbar-track {
    background: hsl(var(--muted) / 0.5);
    border-radius: 10px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb {
    background: hsl(var(--secondary));
    border-radius: 10px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: hsl(var(--accent));
  }
  .custom-scrollbar {
    scrollbar-width: thin;
    scrollbar-color: hsl(var(--secondary)) hsl(var(--muted) / 0.5);
  }

  /* --- NEW: Source-Aware Coloring for Chat --- */
  .rag-source, .wiki-source {
    color: #a7f3d0; /* A pleasant light green for trusted sources */
  }
  .llm-source {
    color: #fde68a; /* A soft orange for general knowledge */
  }
}

# File: src/app/layout.js
// src/app/layout.js (version 1.5)
import { Inter } from "next/font/google";
import "./globals.css";
import { cn } from "@/lib/utils";
import { Toaster } from "@/components/ui/sonner";

const fontSans = Inter({
  subsets: ["latin"],
  variable: "--font-sans",
});

export const metadata = {
  // PWA manifest and theme
  manifest: "/manifest.json",
  themeColor: "#111827",
  
  // App metadata
  title: "Headlines",
  description: "An interface to browse, search, and filter wealth event articles.",
  
  // Base icons, including a dedicated Apple icon
  icons: {
    icon: '/icons/icon-192x192.png',
    shortcut: '/icons/icon-192x192.png',
    apple: '/icons/apple-touch-icon.png',
  },

  // Apple-specific PWA tags for a native-like experience
  appleWebApp: {
    capable: true,
    statusBarStyle: "black-translucent",
    title: "Headlines",
  },
};

export default function RootLayout({ children }) {
  return (
    <html lang="en" className="dark" suppressHydrationWarning>
      <body
        className={cn(
          "min-h-screen font-sans antialiased",
          fontSans.variable
        )}
      >
        {children}
        <Toaster />
      </body>
    </html>
  );
}

# File: src/app/login/actions.js
"use server";

import { cookies } from 'next/headers';

const PASSWORD = "stanley";
const COOKIE_NAME = 'headlines-auth';
const COOKIE_SECRET = process.env.COOKIE_SECRET || 'default-secret-for-dev-please-change-in-production';

/**
 * Server action to verify the password and set the authentication cookie.
 * @param {string} password - The password entered by the user.
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function login(password) {
    // Case-insensitive password check
    if (password.toLowerCase() === PASSWORD) {
        // Password is correct. Set the secure, httpOnly cookie.
        cookies().set({
            name: COOKIE_NAME,
            value: COOKIE_SECRET,
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            path: '/',
            maxAge: 60 * 60 * 24 * 30, // 30 days
        });
        return { success: true };
    } else {
        // Password is incorrect.
        return { success: false, error: "Incorrect password." };
    }
}

# File: src/app/login/layout.js
// This layout applies only to the /login page.
// It ensures that no data-heavy components from the main layout are loaded
// for unauthenticated users.
export default function LoginLayout({ children }) {
  return (
    <div 
      className="min-h-screen flex items-center justify-center p-4"
      style={{
        backgroundColor: 'hsl(224, 71.4%, 4.1%)',
        backgroundImage: `
          radial-gradient(at 27% 37%, hsla(215, 98%, 43%, 0.1) 0px, transparent 50%),
          radial-gradient(at 97% 21%, hsla(217, 91%, 60%, 0.15) 0px, transparent 50%),
          radial-gradient(at 52% 99%, hsla(355, 98%, 51%, 0.1) 0px, transparent 50%),
          radial-gradient(at 10% 90%, hsla(200, 98%, 51%, 0.1) 0px, transparent 50%)
        `
      }}
    >
        {children}
    </div>
  );
}

# File: src/app/login/page.js
"use client";

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardDescription, CardFooter, CardHeader } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Loader2, KeyRound, Shield, Sparkles } from 'lucide-react';
import { toast } from 'sonner';
import { login } from './actions';
import { cn } from '@/lib/utils';

export default function PremiumLoginPortal() {
    const [password, setPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [isError, setIsError] = useState(false);
    const [isFocused, setIsFocused] = useState(false);
    const passwordRef = useRef(null);
    const router = useRouter();

    useEffect(() => {
        if (passwordRef.current) {
            passwordRef.current.focus();
        }
    }, []);

    const handleLogin = async (e) => {
        e.preventDefault();
        setIsLoading(true);
        setIsError(false); // Reset error state on new submission
        
        const result = await login(password);

        if (result.success) {
            toast.success("Authentication successful. Welcome.");
            router.push('/events');
            router.refresh();
        } else {
            toast.error(result.error || "Authentication failed.");
            setIsError(true);
            setIsLoading(false);
        }
    };
    
    return (
        <div>
            {/* Animated background elements */}
            <div className="absolute inset-0 z-0">
                <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-3xl animate-pulse"></div>
                <div className="absolute bottom-1/4 right-1/4 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl animate-pulse" style={{animationDelay: '1s'}}></div>
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-64 h-64 bg-cyan-500/5 rounded-full blur-2xl animate-pulse" style={{animationDelay: '2s'}}></div>
            </div>

            {/* Floating particles */}
            {[...Array(12)].map((_, i) => (
                <div 
                    key={i}
                    className="absolute w-1 h-1 bg-white/40 rounded-full animate-pulse z-0"
                    style={{
                        left: `${Math.random() * 100}%`,
                        top: `${Math.random() * 100}%`,
                        animationDelay: `${Math.random() * 3}s`,
                        animationDuration: `${2 + Math.random() * 2}s`
                    }}
                ></div>
            ))}

            <Card 
                className={cn(
                    "w-full max-w-lg relative z-10",
                    "bg-gradient-to-br from-slate-900/40 via-slate-800/40 to-slate-900/40", 
                    "backdrop-blur-xl border border-white/20", 
                    "shadow-2xl shadow-black/50 rounded-3xl",
                    "transform transition-all duration-700 ease-out",
                    "hover:shadow-3xl hover:shadow-cyan-500/10 hover:scale-[1.02] hover:border-white/30",
                    "opacity-0 animate-fade-in-up",
                    isError ? 'animate-shake' : ''
                )}
                onAnimationEnd={() => setIsError(false)}
            >
                {/* Glossy overlay */}
                <div className="absolute inset-0 bg-gradient-to-br from-white/10 via-transparent to-transparent rounded-3xl pointer-events-none"></div>
                
                <CardHeader className="items-center text-center pt-12 pb-8 px-8 relative">
                    <div className="relative mb-6">
                        <div className="absolute inset-0 bg-gradient-to-r from-cyan-400/30 via-purple-400/30 to-blue-400/30 rounded-full blur-lg opacity-75 animate-pulse"></div>
                        <div className="relative flex items-center justify-center w-20 h-20 bg-gradient-to-br from-gray-800/90 to-gray-900/90 border border-white/20 rounded-full backdrop-blur-sm">
                            <Shield className="h-8 w-8 text-white drop-shadow-lg" />
                            <Sparkles className="absolute -top-1 -right-1 h-4 w-4 text-cyan-300 animate-pulse" />
                        </div>
                    </div>
                    
                    <div className="space-y-2">
                        <h1 className="text-2xl font-bold text-slate-100 drop-shadow-lg">
                            Secure Access Portal
                        </h1>
                        <p className="text-slate-400 text-sm font-medium tracking-wide">
                            Authentication Required
                        </p>
                    </div>
                </CardHeader>

                <form onSubmit={handleLogin}>
                    <CardContent className="px-8 pb-6 space-y-6">
                        <div className="space-y-3">
                            <Label 
                                htmlFor="password" 
                                className="text-slate-300 text-sm font-semibold tracking-wide flex items-center gap-2"
                            >
                                <KeyRound className="h-4 w-4" />
                                Security Credential
                            </Label>
                            <div className="relative group">
                                <Input
                                    ref={passwordRef}
                                    id="password"
                                    type="password"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    onFocus={() => setIsFocused(true)}
                                    onBlur={() => setIsFocused(false)}
                                    disabled={isLoading}
                                    placeholder="Enter access key..."
                                    className={cn(
                                        "h-14 text-lg px-6 rounded-2xl transition-all duration-300",
                                        "bg-gradient-to-r from-slate-900/60 to-slate-800/60",
                                        "border-2",
                                        isFocused ? "border-cyan-400/60" : "border-white/10",
                                        "backdrop-blur-sm text-white placeholder:text-slate-500",
                                        "focus-visible:ring-4 focus-visible:ring-cyan-400/20 focus-visible:ring-offset-0",
                                        "hover:border-white/20 hover:bg-slate-800/70",
                                        "shadow-inner shadow-black/20"
                                    )}
                                />
                                {isFocused && (
                                    <div className="absolute inset-0 rounded-2xl bg-gradient-to-r from-cyan-400/20 to-blue-400/20 blur-xl -z-10 animate-pulse"></div>
                                )}
                            </div>
                        </div>
                    </CardContent>

                    <CardFooter className="px-8 pb-12">
                        <Button 
                            type="submit"
                            disabled={isLoading || !password.trim()}
                            className={cn(
                                "w-full h-14 text-base font-bold rounded-2xl relative overflow-hidden",
                                "transition-all duration-300 ease-out transform",
                                (isLoading || !password.trim()) 
                                    ? 'bg-slate-700/50 text-slate-400 cursor-not-allowed' 
                                    : 'bg-gradient-to-r from-blue-500 via-purple-500 to-cyan-500 text-white hover:scale-[1.02] hover:shadow-2xl hover:shadow-purple-500/50 active:scale-[0.98]'
                            )}
                        >
                            <div className="absolute inset-0 -skew-x-12 bg-gradient-to-r from-transparent via-white/10 to-transparent translate-x-[-200%] group-hover:translate-x-[200%] transition-transform duration-1000"></div>
                            
                            <span className="relative flex items-center justify-center gap-3">
                                {isLoading ? (
                                    <>
                                        <Loader2 className="h-5 w-5 animate-spin" />
                                        Authenticating...
                                    </>
                                ) : (
                                    <>
                                        <Shield className="h-5 w-5" />
                                        Authorize Access
                                    </>
                                )}
                            </span>
                        </Button>
                    </CardFooter>
                </form>

                <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-24 h-1 bg-gradient-to-r from-transparent via-cyan-400 to-transparent rounded-full opacity-60"></div>
            </Card>
        </div>
    );
}

# File: src/components/ArticleCard.jsx
// src/components/ArticleCard.jsx (version 2.0)
"use client";

import { useTransition } from "react";
import { toast } from "sonner";
import { AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Trash2, ExternalLink } from "lucide-react";
import { deleteArticle } from "@/actions/articles";
import { getCountryFlag } from "@/lib/countries";

const getRelevanceBadgeClass = (score) => {
  if (score >= 90) return "bg-red-500/20 text-red-300 border border-red-500/30 shadow-lg shadow-red-500/10";
  if (score >= 75) return "bg-blue-500/20 text-blue-300 border border-blue-500/30 shadow-lg shadow-blue-500/10";
  return "bg-slate-500/20 text-slate-300 border border-slate-500/30";
};

export const ArticleCard = ({ article }) => {
  const [isPending, startTransition] = useTransition();

  const handleDelete = () => {
    startTransition(async () => {
      const result = await deleteArticle(article._id);
      if (result.success) {
        toast.success(result.message);
      } else {
        toast.error(result.message);
      }
    });
  };

  const flag = getCountryFlag(article.country);
  const formattedDate = new Date(article.createdAt).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
  const relevanceScore = article.relevance_article || article.relevance_headline;

  return (
    <AccordionItem
      value={article._id}
      className={`border-slate-700 rounded-xl bg-gradient-to-br from-slate-900 to-slate-800/60 shadow-lg shadow-black/40 transition-all duration-300 hover:shadow-xl hover:shadow-blue-900/30 hover:border-blue-500/50 hover:-translate-y-1 ${isPending ? 'opacity-50 pointer-events-none' : ''}`}
    >
      <TooltipProvider delayDuration={100}>
        <div className="p-4">
            {/* --- RESPONSIVE HEADER --- */}
            <div className="flex items-center justify-between gap-2 mb-2">
                <div className="flex items-center gap-2 min-w-0">
                    <Badge className={`text-sm font-bold px-2.5 py-1 ${getRelevanceBadgeClass(relevanceScore)}`}>
                      {relevanceScore}
                    </Badge>
                    <span className="text-lg hidden sm:inline">{flag}</span>
                    <p className="text-xs sm:text-sm text-slate-400 truncate">{article.newspaper}</p>
                </div>
                <div className="flex items-center flex-shrink-0">
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button variant="ghost" size="icon" onClick={() => window.open(article.link, '_blank')} className="text-slate-400 hover:text-blue-400 hover:bg-blue-500/10 h-8 w-8">
                        <ExternalLink className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>Open in new tab</TooltipContent>
                  </Tooltip>
                  <AlertDialog>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <AlertDialogTrigger asChild>
                          <Button variant="ghost" size="icon" disabled={isPending} className="text-slate-400 hover:text-red-400 hover:bg-red-500/10 h-8 w-8">
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </AlertDialogTrigger>
                      </TooltipTrigger>
                      <TooltipContent>Delete article</TooltipContent>
                    </Tooltip>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                        <AlertDialogDescription>This will permanently delete the article from the database.</AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction onClick={handleDelete}>Continue</AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </div>
            </div>

            <AccordionTrigger className="p-0 hover:no-underline text-left">
              <div className="flex-grow min-w-0">
                <p className="font-serif font-bold text-base sm:text-lg text-slate-100 line-clamp-3">
                  <span className="text-lg sm:hidden mr-2">{flag}</span>
                  {article.headline_en || `(en N/S): ${article.headline}`}
                </p>
              </div>
            </AccordionTrigger>
        </div>
      </TooltipProvider>

      <AccordionContent className="p-4 pt-0">
        <div className="border-t border-slate-700/50 pt-4 mt-2 space-y-4">
          {article.assessment_article && (
            <div>
              <h4 className="font-semibold text-sm text-slate-300 mb-1">Intelligence Analysis</h4>
              <p className="text-sm text-slate-400 italic break-words">"{article.assessment_article}"</p>
            </div>
          )}
          {article.key_individuals && article.key_individuals.length > 0 && (
            <div>
              <h4 className="font-semibold text-sm text-slate-300 mb-1">Key Individuals & Contacts</h4>
              <ul className="list-disc list-inside text-sm text-slate-400">
                {article.key_individuals.map(person => (
                  <li key={person.name}>
                    <strong>{person.name}</strong> ({person.role_in_event} at {person.company})
                    {person.email_suggestion && <span className="text-xs text-slate-500 ml-2">{person.email_suggestion}</span>}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </AccordionContent>
    </AccordionItem>
  );
};

# File: src/components/ArticleList.jsx
import { Accordion } from '@/components/ui/accordion';
import { ArticleCard } from '@/components/ArticleCard';

export const ArticleList = ({ articles }) => {
  return (
    <Accordion type="single" collapsible className="w-full space-y-2">
      {articles.map((article) => (
        <ArticleCard key={article._id} article={article} />
      ))}
    </Accordion>
  );
};

# File: src/components/ArticlesView.jsx
// src/components/ArticlesView.jsx (version 1.3)
"use client";

import { useState, useEffect, useCallback } from 'react';
import { ArticleList } from '@/components/ArticleList';
import { InfiniteScrollLoader } from '@/components/InfiniteScrollLoader';
import { getArticles } from '@/actions/articles';
import { ARTICLES_PER_PAGE } from '@/config/constants';
import { useRealtimeUpdates } from '@/hooks/use-realtime-updates'; // NEW

export function ArticlesView({ initialArticles, searchParams }) {
    const [articles, setArticles] = useState(initialArticles);
    const [page, setPage] = useState(1);
    const [hasMore, setHasMore] = useState(initialArticles.length === ARTICLES_PER_PAGE);
    const [isLoading, setIsLoading] = useState(false);
    
    useRealtimeUpdates(); // NEW: Activate real-time listener

    useEffect(() => {
        setArticles(initialArticles);
        setPage(1);
        setHasMore(initialArticles.length === ARTICLES_PER_PAGE);
    }, [initialArticles]);

    const loadMoreArticles = useCallback(async () => {
        if (isLoading || !hasMore) return;
        setIsLoading(true);

        const nextPage = page + 1;
        const newArticles = await getArticles({
            page: nextPage,
            filters: { q: searchParams.q, country: searchParams.country },
            sort: searchParams.sort,
        });

        if (newArticles.length > 0) {
            setArticles(prev => [...prev, ...newArticles]);
            setPage(nextPage);
        }
        
        if (newArticles.length < ARTICLES_PER_PAGE) {
            setHasMore(false);
        }
        
        setIsLoading(false);
    }, [isLoading, hasMore, page, searchParams]);

    return (
        <div className="max-w-5xl mx-auto space-y-6">
            {articles.length > 0 ? (
                <>
                    <ArticleList articles={articles} />
                    <InfiniteScrollLoader onLoadMore={loadMoreArticles} hasMore={hasMore} />
                </>
            ) : (
                <div className="text-center text-gray-500 py-20 rounded-lg bg-black/20 border border-white/10">
                    <p>No articles found matching your criteria.</p>
                </div>
            )}
        </div>
    );
}

# File: src/components/ChatManager.jsx
// src/components/ChatManager.jsx (version 1.5)
"use client";

import { useEffect } from 'react';
import { ChatSidebar } from './chat/ChatSidebar';
import { ChatView } from './ChatView';
import { useAppStore } from '@/store/use-app-store';
import { useHasHydrated } from '@/hooks/use-has-hydrated';
import { Loader2 } from 'lucide-react';

export function ChatManager() {
    const {
        chats, 
        activeChatId, 
        createChat, 
        selectChat,
        updateChatTitle,
        getMessagesForChat,
        setMessagesForChat,
        init,
    } = useAppStore();

    // Use the new hook to gate rendering until hydration is complete.
    const hasHydrated = useHasHydrated();

    useEffect(() => {
        // The init logic now safely runs only after hydration is confirmed.
        if(hasHydrated) {
            init();
        }
    }, [hasHydrated, init]);

    // The condition is now based on the reliable hydration status.
    // This ensures server and initial client renders are identical (showing the loader).
    // The component will re-render and show the chat UI only after the
    // `useHasHydrated` hook returns true.
    if (!hasHydrated || !activeChatId) {
        return (
            <div className="flex items-center justify-center h-full text-slate-500">
                <Loader2 className="h-6 w-6 animate-spin mr-3" />
                <p>Initializing Chat Interface...</p>
            </div>
        );
    }
    
    return (
        <div className="grid grid-cols-1 md:grid-cols-[280px_1fr] h-full gap-4">
            <div className="hidden md:flex md:flex-col">
                <ChatSidebar 
                    chats={chats}
                    activeChatId={activeChatId}
                    createChat={createChat}
                    selectChat={selectChat}
                />
            </div>
            <ChatView
                key={activeChatId}
                chatId={activeChatId}
                updateChatTitle={updateChatTitle}
                getMessages={getMessagesForChat}
                setMessages={setMessagesForChat}
            />
        </div>
    );
}

# File: src/components/ChatView.jsx
// src/components/ChatView.jsx (version 2.1)
"use client";

import { useChat } from 'ai/react';
import { useEffect, useRef } from 'react';
import { Card } from '@/components/ui/card';
import { ChatMessage } from '@/components/chat/ChatMessage';
import { ChatInput } from '@/components/chat/ChatInput';
import { ChatScrollAnchor } from '@/components/chat/ChatScrollAnchor';
import { ChatThinkingIndicator } from '@/components/chat/ChatThinkingIndicator';
import { useAppStore } from '@/store/use-app-store';
import { generateChatTitle } from '@/actions/chat';

export function ChatView({ chatId, updateChatTitle, getMessages, setMessages }) {
    const inputRef = useRef(null);
    const { chatContextPrompt, setChatContextPrompt } = useAppStore(state => ({
        chatContextPrompt: state.chatContextPrompt,
        setChatContextPrompt: state.setChatContextPrompt
    }));
    
    const { messages, input, setInput, handleInputChange, handleSubmit, isLoading, append } = useChat({
        id: chatId,
        api: '/api/chat',
        initialMessages: getMessages(chatId),
        onFinish: async (message) => {
            // The `messages` array from the hook is the source of truth.
            // At this point, it already contains the user's message and the complete assistant message.
            setMessages(chatId, messages);

            // --- BUG FIX ---
            // The check is now performed on the `messages` array directly.
            // A new chat's first exchange will result in messages.length being exactly 2.
            if (messages.length === 2) {
                const result = await generateChatTitle(messages);
                if (result.success) {
                    updateChatTitle(chatId, result.title);
                }
            }
            // --- END BUG FIX ---
        },
    });

    useEffect(() => {
        if (!isLoading && inputRef.current) {
            setTimeout(() => {
                inputRef.current.focus();
            }, 100);
        }
    }, [isLoading]);

    useEffect(() => {
        if (chatContextPrompt) {
            const userMessage = { role: 'user', content: chatContextPrompt };
            append(userMessage);
            setChatContextPrompt('');
        }
    }, [chatContextPrompt, append, setChatContextPrompt]);
    
    const customHandleSubmit = (e) => {
        e.preventDefault();
        handleSubmit(e);
    };

    return (
        <div className="flex-grow flex flex-col justify-between h-full min-h-0">
            <Card className="bg-black/20 backdrop-blur-sm border border-white/10 shadow-2xl shadow-black/30 h-full flex flex-col">
                <div className="flex-grow overflow-y-auto p-4 space-y-6 custom-scrollbar">
                    {messages.length === 0 && !isLoading && (
                        <div className="flex flex-col items-center justify-center h-full text-slate-500">
                            <p className="text-lg">Ask anything about the knowledge base.</p>
                        </div>
                    )}
                    {messages.map(m => (
                        <ChatMessage key={m.id} message={m} />
                    ))}
                    {isLoading && <ChatThinkingIndicator status="Thinking..." />}
                    <ChatScrollAnchor messages={messages} />
                </div>
                <div className="px-4 pb-4">
                    <ChatInput 
                        inputRef={inputRef}
                        input={input}
                        setInput={setInput}
                        handleInputChange={handleInputChange}
                        handleSubmit={customHandleSubmit}
                        isLoading={isLoading}
                    />
                </div>
            </Card>
        </div>
    );
}

# File: src/components/EventList.jsx
import { Accordion } from '@/components/ui/accordion';
import { SynthesizedEventCard } from '@/components/SynthesizedEventCard';

export const EventList = ({ events }) => {
  return (
    <Accordion type="single" collapsible className="w-full space-y-4">
      {events.map((event) => (
        <SynthesizedEventCard key={event.event_key} event={event} />
      ))}
    </Accordion>
  );
};

# File: src/components/EventsView.jsx
// src/components/EventsView.jsx (version 1.3)
"use client";

import { useState, useEffect, useCallback } from 'react';
import { EventList } from '@/components/EventList';
import { InfiniteScrollLoader } from '@/components/InfiniteScrollLoader';
import { getEvents } from '@/actions/events';
import { EVENTS_PER_PAGE } from '@/config/constants';
import { useRealtimeUpdates } from '@/hooks/use-realtime-updates'; // NEW

export function EventsView({ initialEvents, searchParams }) {
    const [events, setEvents] = useState(initialEvents);
    const [page, setPage] = useState(1);
    const [hasMore, setHasMore] = useState(initialEvents.length === EVENTS_PER_PAGE);
    const [isLoading, setIsLoading] = useState(false);
    
    useRealtimeUpdates(); // NEW: Activate real-time listener

    useEffect(() => {
        setEvents(initialEvents);
        setPage(1);
        setHasMore(initialEvents.length === EVENTS_PER_PAGE);
    }, [initialEvents]);

    const loadMoreEvents = useCallback(async () => {
        if (isLoading || !hasMore) return;
        setIsLoading(true);

        const nextPage = page + 1;
        const newEvents = await getEvents({
            page: nextPage,
            filters: { q: searchParams.q, country: searchParams.country },
            sort: searchParams.sort,
        });

        if (newEvents.length > 0) {
            setEvents(prev => [...prev, ...newEvents]);
            setPage(nextPage);
        }

        if (newEvents.length < EVENTS_PER_PAGE) {
            setHasMore(false);
        }
        
        setIsLoading(false);
    }, [isLoading, hasMore, page, searchParams]);

    return (
        <div className="max-w-5xl mx-auto space-y-6">
            {events.length > 0 ? (
                <>
                    <EventList events={events} />
                    <InfiniteScrollLoader onLoadMore={loadMoreEvents} hasMore={hasMore} />
                </>
            ) : (
                <div className="text-center text-gray-500 py-20 rounded-lg bg-black/20 border border-white/10">
                    <p>No synthesized events found matching your criteria.</p>
                </div>
            )}
        </div>
    );
}

# File: src/components/Filters.jsx
'use client';

import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { useState, useEffect } from 'react';
import { useDebounce } from '@/hooks/use-debounce';
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from './ui/button';
import { X } from 'lucide-react';

export const Filters = ({ uniqueSources, uniqueCountries }) => {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const [filters, setFilters] = useState({
    q: searchParams.get('q') || '',
    min_relevance: searchParams.get('min_relevance') || '10',
    source: searchParams.get('source') || '',
    country: searchParams.get('country') || '',
    sort: searchParams.get('sort') || 'date_desc',
  });

  const debouncedFilters = useDebounce(filters, 500);

  useEffect(() => {
    const params = new URLSearchParams(window.location.search);
    
    Object.keys(debouncedFilters).forEach(key => {
      const value = debouncedFilters[key];
      if (value) {
        params.set(key, value);
      } else {
        params.delete(key);
      }
    });

    params.set('page', '1');
    router.push(`${pathname}?${params.toString()}`);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedFilters, pathname, router]);

  const handleFilterChange = (key, value) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };
  
  const clearFilters = () => {
    const newFilters = { q: '', min_relevance: '10', source: '', country: '', sort: 'date_desc' };
    setFilters(newFilters);
  };
  
  const hasActiveFilters = filters.q || filters.min_relevance !== '10' || filters.source || filters.country;

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-x-4 gap-y-6 items-end">
      {/* Search Input */}
      <div className="space-y-2 lg:col-span-2 xl:col-span-1">
        <Label htmlFor="search" className="text-slate-300">Search</Label>
        <Input id="search" placeholder="e.g., 'acquisition'..." value={filters.q} onChange={(e) => handleFilterChange('q', e.target.value)} className="bg-slate-900/80 border-slate-700"/>
      </div>

      {/* Country Select */}
      <div className="space-y-2">
        <Label htmlFor="country" className="text-slate-300">Country</Label>
        <Select value={filters.country} onValueChange={(value) => handleFilterChange('country', value === 'all-countries' ? '' : value)}>
          <SelectTrigger id="country" className="w-full bg-slate-900/80 border-slate-700"><SelectValue placeholder="All Countries" /></SelectTrigger>
          <SelectContent>
            <SelectItem value="all-countries">All Countries</SelectItem>
            {uniqueCountries.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}
          </SelectContent>
        </Select>
      </div>

      {/* Source Select */}
      <div className="space-y-2">
        <Label htmlFor="source" className="text-slate-300">Source</Label>
        <Select value={filters.source} onValueChange={(value) => handleFilterChange('source', value === 'all-sources' ? '' : value)}>
          <SelectTrigger id="source" className="w-full bg-slate-900/80 border-slate-700"><SelectValue placeholder="All Sources" /></SelectTrigger>
          <SelectContent>
            <SelectItem value="all-sources">All Sources</SelectItem>
            {uniqueSources.map(s => <SelectItem key={s} value={s}>{s}</SelectItem>)}
          </SelectContent>
        </Select>
      </div>
      
      {/* Sort Select */}
      <div className="space-y-2">
        <Label htmlFor="sort" className="text-slate-300">Sort By</Label>
        <Select value={filters.sort} onValueChange={(value) => handleFilterChange('sort', value)}>
          <SelectTrigger id="sort" className="w-full bg-slate-900/80 border-slate-700"><SelectValue placeholder="Select sorting" /></SelectTrigger>
          <SelectContent>
            <SelectItem value="date_desc">Date (Newest First)</SelectItem>
            <SelectItem value="date_asc">Date (Oldest First)</SelectItem>
            <SelectItem value="relevance_desc">Relevance (High to Low)</SelectItem>
            <SelectItem value="relevance_asc">Relevance (Low to High)</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Clear Button */}
      <div className="flex items-end">
        {hasActiveFilters && (
          <Button variant="ghost" onClick={clearFilters} className="w-full text-slate-400 hover:text-red-400 hover:bg-red-500/10">
            <X className="mr-2 h-4 w-4" /> Clear
          </Button>
        )}
      </div>
    </div>
  );
};

# File: src/components/GlobalFilters.jsx
// src/components/GlobalFilters.jsx (version 1.3)
"use client";

import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { useState, useEffect, useMemo } from 'react';
import { useDebounce } from '@/hooks/use-debounce';
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from '@/components/ui/button';
import { X } from 'lucide-react';
import { Card, CardContent } from './ui/card';

export function GlobalFilters({ uniqueCountries }) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const initialState = useMemo(() => ({
    q: searchParams.get('q') || '',
    country: searchParams.get('country') || '',
    sort: searchParams.get('sort') || 'date_desc',
  }), [searchParams]);

  const [filters, setFilters] = useState(initialState);

  const debouncedFilters = useDebounce(filters, 500);

  useEffect(() => {
    const params = new URLSearchParams(searchParams.toString());
    
    Object.keys(debouncedFilters).forEach(key => {
      const value = debouncedFilters[key];
      if (value) {
        params.set(key, value);
      } else {
        params.delete(key);
      }
    });

    params.set('page', '1');
    router.push(`${pathname}?${params.toString()}`, { scroll: false });
  }, [debouncedFilters, pathname, router, searchParams]);

  const handleFilterChange = (key, value) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  };
  
  const clearFilters = () => {
    setFilters({ q: '', country: '', sort: 'date_desc' });
  };
  
  const hasActiveFilters = filters.q || filters.country || filters.sort !== 'date_desc';

  return (
    <Card className="mb-8 bg-black/20 backdrop-blur-sm border-white/10 shadow-lg shadow-black/30">
        <CardContent className="p-4">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 items-end">
                <div className="space-y-1.5 md:col-span-2 lg:col-span-3">
                    <Label htmlFor="search" className="text-slate-300">Search</Label>
                    <Input id="search" placeholder="Search by name, company, or keyword..." value={filters.q} onChange={(e) => handleFilterChange('q', e.target.value)} className="bg-slate-900/80 border-slate-700"/>
                </div>
                <div className="space-y-1.5">
                    <Label htmlFor="country" className="text-slate-300">Country</Label>
                    <Select value={filters.country} onValueChange={(value) => handleFilterChange('country', value === 'all-countries' ? '' : value)}>
                        <SelectTrigger id="country" className="w-full bg-slate-900/80 border-slate-700"><SelectValue placeholder="All Countries" /></SelectTrigger>
                        <SelectContent>
                            <SelectItem value="all-countries">All Countries</SelectItem>
                            {uniqueCountries.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}
                        </SelectContent>
                    </Select>
                </div>
                <div className="flex items-end space-x-2">
                    <div className="space-y-1.5 flex-grow">
                        <Label htmlFor="sort" className="text-slate-300">Sort By</Label>
                        <Select value={filters.sort} onValueChange={(value) => handleFilterChange('sort', value)}>
                          <SelectTrigger id="sort" className="w-full bg-slate-900/80 border-slate-700"><SelectValue placeholder="Select sorting" /></SelectTrigger>
                          <SelectContent>
                            <SelectItem value="date_desc">Date (Newest First)</SelectItem>
                            <SelectItem value="date_asc">Date (Oldest First)</SelectItem>
                            <SelectItem value="relevance_desc">Relevance (High to Low)</SelectItem>
                          </SelectContent>
                        </Select>
                    </div>
                    {hasActiveFilters && (
                        <Button variant="ghost" size="icon" onClick={clearFilters} className="h-9 w-9 shrink-0 text-slate-400 hover:text-red-400 hover:bg-red-500/10">
                            <X className="h-4 w-4" />
                        </Button>
                    )}
                </div>
            </div>
        </CardContent>
    </Card>
  );
}

# File: src/components/Header.jsx
// src/components/Header.jsx (version 1.4)
"use client";

import { Briefcase } from 'lucide-react';
import { InstallPwaButton } from '@/components/InstallPwaButton';
import { PushNotificationManager } from '@/components/PushNotificationManager';

export const Header = ({ articleCount, eventCount }) => {
  return (
    <header className="mb-4 sm:mb-6 relative">
      <div className="absolute top-2 right-2 flex items-center gap-1">
        <InstallPwaButton />
        <PushNotificationManager />
      </div>

      <div className="flex flex-row items-center justify-center gap-x-3 sm:gap-x-4 mb-3 pt-8 sm:pt-0">
        <Briefcase size={28} className="text-blue-400 sm:size-10" />
        <h1 className="text-3xl sm:text-4xl font-extrabold tracking-tight text-slate-100 text-center sm:text-left">
          Headlines<span className="hidden sm:inline"> Intelligence</span>
        </h1>
      </div>
      
      <p className="text-center text-sm sm:text-base text-slate-400 max-w-3xl mx-auto">
        Search and analyze 
        <span className="font-bold text-slate-300"> {eventCount?.toLocaleString()} </span> 
        events from 
        <span className="font-bold text-slate-300"> {articleCount?.toLocaleString()} </span> 
        articles.
      </p>
    </header>
  );
};

# File: src/components/IOSInstallInstructions.jsx
// src/components/IOSInstallInstructions.jsx (version 1.0)
"use client";

import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { Share, PlusSquare } from "lucide-react";

export function IOSInstallInstructions({ open, onOpenChange }) {
    return (
        <Dialog open={open} onOpenChange={onOpenChange}>
            <DialogContent className="sm:max-w-md bg-slate-900 border-slate-700">
                <DialogHeader>
                    <DialogTitle>Install on your iPhone</DialogTitle>
                    <DialogDescription>
                        To install the app, please follow these steps:
                    </DialogDescription>
                </DialogHeader>
                <div className="py-4 space-y-4 text-sm text-slate-300">
                    <div className="flex items-center gap-4">
                        <div className="flex-shrink-0 w-10 h-10 bg-slate-800 rounded-lg flex items-center justify-center">
                            <Share className="h-5 w-5" />
                        </div>
                        <p>1. Tap the <span className="font-bold">Share</span> button in Safari's bottom toolbar.</p>
                    </div>
                    <div className="flex items-center gap-4">
                        <div className="flex-shrink-0 w-10 h-10 bg-slate-800 rounded-lg flex items-center justify-center">
                            <PlusSquare className="h-5 w-5" />
                        </div>
                        <p>2. Scroll down and tap '<span className="font-bold">Add to Home Screen</span>'.</p>
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
}

# File: src/components/InfiniteScrollLoader.jsx
// src/components/InfiniteScrollLoader.jsx (version 1.0)
"use client";

import { useEffect, useRef } from 'react';
import { useInView } from 'react-intersection-observer';
import { Loader2 } from 'lucide-react';

export function InfiniteScrollLoader({ onLoadMore, hasMore }) {
    const { ref, inView } = useInView({
        threshold: 0,
        triggerOnce: false,
    });

    useEffect(() => {
        if (inView && hasMore) {
            onLoadMore();
        }
    }, [inView, hasMore, onLoadMore]);

    return (
        <div ref={ref} className="flex justify-center items-center p-4">
            {hasMore && <Loader2 className="h-6 w-6 animate-spin text-slate-500" />}
        </div>
    );
}

# File: src/components/InstallPwaButton.jsx
// src/components/InstallPwaButton.jsx (version 2.0)
"use client";

import { useState, useEffect } from 'react';
import { Button } from './ui/button';
import { Download, Smartphone } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { IOSInstallInstructions } from './IOSInstallInstructions';

export function InstallPwaButton() {
  const [installPrompt, setInstallPrompt] = useState(null);
  const [isAppInstalled, setIsAppInstalled] = useState(false);
  const [isIOS, setIsIOS] = useState(false);
  const [showIOSInstructions, setShowIOSInstructions] = useState(false);

  useEffect(() => {
    // Detect iOS
    const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    setIsIOS(isIOSDevice);

    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault();
      // This event only fires on supported browsers (e.g., Chrome on Android/Desktop)
      setInstallPrompt(e);
    };

    const checkInstallStatus = () => {
      // Standalone mode is a strong indicator of an installed PWA
      if (window.matchMedia('(display-mode: standalone)').matches) {
        setIsAppInstalled(true);
      }
    };

    checkInstallStatus();
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    window.addEventListener('appinstalled', () => {
      setIsAppInstalled(true);
      setInstallPrompt(null);
    });

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    };
  }, []);

  const handleInstallClick = async () => {
    if (!installPrompt) return;
    installPrompt.prompt();
    await installPrompt.userChoice;
    setInstallPrompt(null);
  };

  const handleIOSClick = () => {
    setShowIOSInstructions(true);
  };

  // If the app is already installed, render nothing.
  if (isAppInstalled) {
    return null;
  }

  // If on iOS, show the button that triggers the instruction modal.
  if (isIOS) {
    return (
      <>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="ghost" size="icon" onClick={handleIOSClick}>
                <Smartphone className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>Install on iPhone</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <IOSInstallInstructions open={showIOSInstructions} onOpenChange={setShowIOSInstructions} />
      </>
    );
  }

  // If on a compatible browser and the install prompt is available, show the direct install button.
  if (installPrompt) {
    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button variant="ghost" size="icon" onClick={handleInstallClick}>
              <Download className="h-4 w-4" />
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            <p>Install App</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    );
  }

  // Fallback for other scenarios (e.g., desktop browser without PWA support) - show nothing.
  return null;
}

# File: src/components/MainNavTabs.jsx
// src/components/MainNavTabs.jsx (version 1.2)
"use client";

import { usePathname } from 'next/navigation';
import Link from 'next/link';
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Zap, Newspaper, UploadCloud, MessageSquare } from 'lucide-react';

const TABS = [
    { value: 'events', label: 'Events', icon: Zap },
    { value: 'articles', label: 'Articles', icon: Newspaper },
    { value: 'upload', label: 'Upload', icon: UploadCloud },
    { value: 'chat', label: 'Chat', icon: MessageSquare },
];

export function MainNavTabs() {
    const pathname = usePathname();
    const currentView = pathname.substring(1) || 'events';

    return (
        <Tabs value={currentView} className="w-full">
            <div className="flex justify-center">
                <TabsList className="h-12 rounded-full bg-slate-900/60 backdrop-blur-sm border border-slate-700/80 p-2 shadow-lg">
                    {TABS.map((tab) => (
                        <TabsTrigger key={tab.value} value={tab.value} asChild className="px-3 sm:px-6 rounded-full data-[state=active]:bg-blue-600/80 data-[state=active]:text-white">
                            <Link href={`/${tab.value}`} className="flex items-center gap-2">
                                <tab.icon className="h-4 w-4" />
                                <span className="hidden sm:inline">{tab.label}</span>
                            </Link>
                        </TabsTrigger>
                    ))}
                </TabsList>
            </div>
        </Tabs>
    );
}

# File: src/components/PaginationControls.jsx
'use client';

import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { Button } from "@/components/ui/button";

export const PaginationControls = ({ totalPages, currentPage }) => {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const handlePageChange = (newPage) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set('page', newPage.toString());
    router.push(`${pathname}?${params.toString()}`);
  };

  return (
    <div className="flex items-center gap-2">
      <Button
        variant="secondary"
        size="sm"
        onClick={() => handlePageChange(currentPage - 1)}
        disabled={currentPage <= 1}
      >
        Previous
      </Button>
      <span className="text-slate-400 font-medium text-sm">
        Page {currentPage} of {totalPages}
      </span>
      <Button
        variant="secondary"
        size="sm"
        onClick={() => handlePageChange(currentPage + 1)}
        disabled={currentPage >= totalPages}
      >
        Next
      </Button>
    </div>
  );
};

# File: src/components/PushNotificationManager.jsx
// src/components/PushNotificationManager.jsx (version 2.0)
"use client";

import { Button } from './ui/button';
import { Bell, BellOff, Loader2 } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { usePushManager } from '@/hooks/use-push-manager';

export function PushNotificationManager() {
    const { isSupported, isSubscribed, isLoading, subscribe } = usePushManager();

    // If push notifications aren't supported by the browser, render nothing.
    if (!isSupported) {
        return null;
    }
    
    // The UI is now a clean representation of the state from the hook.
    return (
        <TooltipProvider>
            <Tooltip>
                <TooltipTrigger asChild>
                    <Button 
                        variant="ghost" 
                        size="icon" 
                        onClick={subscribe} 
                        disabled={isLoading || isSubscribed}
                        aria-label={isSubscribed ? "Notifications Enabled" : "Enable Notifications"}
                    >
                        {isLoading && <Loader2 className="h-4 w-4 animate-spin" />}
                        {!isLoading && isSubscribed && <Bell className="h-4 w-4 text-green-400" />}
                        {!isLoading && !isSubscribed && <BellOff className="h-4 w-4" />}
                    </Button>
                </TooltipTrigger>
                <TooltipContent>
                    <p>{isSubscribed ? "Notifications Enabled" : "Enable Notifications"}</p>
                </TooltipContent>
            </Tooltip>
        </TooltipProvider>
    );
}

# File: src/components/SkeletonCard.jsx
import { Card, CardContent } from "@/components/ui/card";

export const SkeletonCard = () => {
  return (
    <Card className="bg-slate-900/50 border-slate-700/50 animate-pulse">
      <CardContent className="p-6">
        <div className="flex items-start gap-6">
          {/* Left Column Skeleton */}
          <div className="flex flex-col items-center shrink-0">
            <div className="h-10 w-14 bg-slate-700 rounded-md"></div>
            <div className="h-4 w-10 bg-slate-700 rounded mt-1"></div>
          </div>
          {/* Right Column Skeleton */}
          <div className="flex-grow min-w-0 space-y-3">
            <div className="h-6 w-3/4 bg-slate-700 rounded"></div>
            <div className="h-4 w-full bg-slate-700 rounded"></div>
            <div className="h-4 w-5/6 bg-slate-700 rounded"></div>
            <div className="h-4 w-1/3 bg-slate-700 rounded mt-2"></div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

# File: src/components/StatsBar.jsx
import { Card } from "@/components/ui/card";
import { Newspaper, Zap } from "lucide-react";

export function StatsBar({ articleCount, eventCount }) {
  return (
    <Card className="mb-8 bg-black/20 backdrop-blur-sm border-white/10 shadow-lg shadow-black/30">
        <div className="p-4 flex justify-around items-center">
            <div className="text-center">
                <div className="flex items-center justify-center gap-2 text-blue-300">
                    <Zap className="h-5 w-5" />
                    <span className="text-2xl font-bold">{eventCount.toLocaleString()}</span>
                </div>
                <p className="text-xs text-slate-400 uppercase tracking-wider">Synthesized Events</p>
            </div>
            <div className="h-12 w-px bg-slate-700"></div>
            <div className="text-center">
                <div className="flex items-center justify-center gap-2 text-slate-300">
                    <Newspaper className="h-5 w-5" />
                    <span className="text-2xl font-bold">{articleCount.toLocaleString()}</span>
                </div>
                <p className="text-xs text-slate-400 uppercase tracking-wider">Raw Articles</p>
            </div>
        </div>
    </Card>
  );
}

# File: src/components/SynthesizedEventCard.jsx
// src/components/SynthesizedEventCard.jsx (version 1.4)
"use client";

import { useTransition } from "react";
import { useRouter } from 'next/navigation';
import { toast } from "sonner";
import { AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Users, FileText, Trash2, MessageSquarePlus } from "lucide-react";
import { deleteEvent } from "@/actions/events";
import { getCountryFlag } from "@/lib/countries";
import { useAppStore } from "@/store/use-app-store";

const getRelevanceBadgeClass = (score) => {
  if (score >= 90) return "bg-red-500/20 text-red-300 border border-red-500/30 shadow-lg shadow-red-500/10";
  if (score >= 75) return "bg-blue-500/20 text-blue-300 border border-blue-500/30 shadow-lg shadow-blue-500/10";
  return "bg-slate-500/20 text-slate-300 border border-slate-500/30";
};

export const SynthesizedEventCard = ({ event }) => {
  const [isPending, startTransition] = useTransition();
  const setChatContextPrompt = useAppStore((state) => state.setChatContextPrompt);
  const router = useRouter();

  const handleDelete = () => {
    startTransition(async () => {
      const result = await deleteEvent(event._id);
      if (result.success) {
        toast.success(result.message);
      } else {
        toast.error(result.message);
      }
    });
  };

  const handleChatAboutEvent = () => {
    const prompt = `Tell me more about the event: "${event.synthesized_headline}". What are the key implications?`;
    setChatContextPrompt(prompt);
    router.push('/chat');
  };
  
  const flag = getCountryFlag(event.country);
  const formattedDate = new Date(event.createdAt).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });

  return (
    <AccordionItem 
      value={event.event_key} 
      className={`relative border-slate-700 rounded-xl bg-gradient-to-br from-slate-900 to-slate-800/60 shadow-lg shadow-black/40 transition-all duration-300 hover:shadow-xl hover:shadow-blue-900/30 hover:border-blue-500/50 hover:-translate-y-1 ${isPending ? 'opacity-50 pointer-events-none' : ''}`}
    >
      <TooltipProvider delayDuration={100}>
        <div className="p-4">
            {/* --- MOBILE LAYOUT --- */}
            <div className="sm:hidden">
                <div className="flex justify-between items-start gap-2 mb-2">
                    <div className="flex items-center gap-2 min-w-0">
                        <Badge className={`text-sm font-bold px-2.5 py-1 ${getRelevanceBadgeClass(event.highest_relevance_score)}`}>
                            {event.highest_relevance_score}
                        </Badge>
                        <h3 className="font-serif font-bold text-base text-slate-100 line-clamp-2">
                            <span className="text-lg mr-2 align-middle">{flag}</span>
                            {event.synthesized_headline}
                        </h3>
                    </div>
                    <div className="flex flex-col items-center gap-1">
                        <Button variant="ghost" size="icon" onClick={handleChatAboutEvent} className="text-slate-400 hover:text-blue-400 hover:bg-blue-500/10 h-8 w-8">
                            <MessageSquarePlus className="h-4 w-4" />
                        </Button>
                        <AlertDialog>
                            <AlertDialogTrigger asChild>
                              <Button variant="ghost" size="icon" disabled={isPending} className="text-slate-400 hover:text-red-400 hover:bg-red-500/10 h-8 w-8">
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            </AlertDialogTrigger>
                            <AlertDialogContent>
                              <AlertDialogHeader><AlertDialogTitle>Are you sure?</AlertDialogTitle><AlertDialogDescription>This will permanently delete the event.</AlertDialogDescription></AlertDialogHeader>
                              <AlertDialogFooter><AlertDialogCancel>Cancel</AlertDialogCancel><AlertDialogAction onClick={handleDelete}>Continue</AlertDialogAction></AlertDialogFooter>
                            </AlertDialogContent>
                        </AlertDialog>
                    </div>
                </div>
                <p className="text-sm text-slate-300 leading-relaxed">{event.synthesized_summary}</p>
            </div>

            {/* --- DESKTOP LAYOUT --- */}
            <div className="hidden sm:flex items-start gap-6">
                <div className="flex flex-col items-center shrink-0">
                  <Badge className={`text-xl font-bold px-4 py-2 ${getRelevanceBadgeClass(event.highest_relevance_score)}`}>
                    {event.highest_relevance_score}
                  </Badge>
                  <span className="text-xs text-slate-500 mt-1">Score</span>
                </div>
                <div className="flex-grow min-w-0 pr-20">
                  <h3 className="font-serif font-bold text-xl text-slate-100 mb-2">
                    <span className="text-2xl mr-3 align-middle">{flag}</span>
                    {event.synthesized_headline}
                  </h3>
                  <p className="text-slate-300 leading-relaxed">{event.synthesized_summary}</p>
                </div>
                 <div className="absolute top-4 right-4 z-10 flex gap-1">
                    <Tooltip>
                        <TooltipTrigger asChild>
                            <Button variant="ghost" size="icon" onClick={handleChatAboutEvent} className="text-slate-400 hover:text-blue-400 hover:bg-blue-500/10 h-8 w-8">
                                <MessageSquarePlus className="h-4 w-4" />
                            </Button>
                        </TooltipTrigger>
                        <TooltipContent>Ask AI about this event</TooltipContent>
                    </Tooltip>
                    <AlertDialog>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <AlertDialogTrigger asChild>
                              <Button variant="ghost" size="icon" disabled={isPending} className="text-slate-400 hover:text-red-400 hover:bg-red-500/10 h-8 w-8">
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            </AlertDialogTrigger>
                          </TooltipTrigger>
                          <TooltipContent>Delete Event</TooltipContent>
                        </Tooltip>
                        <AlertDialogContent>
                          <AlertDialogHeader><AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle><AlertDialogDescription>This will permanently delete the synthesized event.</AlertDialogDescription></AlertDialogHeader>
                          <AlertDialogFooter><AlertDialogCancel>Cancel</AlertDialogCancel><AlertDialogAction onClick={handleDelete}>Continue</AlertDialogAction></AlertDialogFooter>
                        </AlertDialogContent>
                    </AlertDialog>
                </div>
            </div>

            {/* --- SHARED FOOTER --- */}
            <div className="mt-4 pt-4 border-t border-slate-800/50 flex flex-col sm:flex-row justify-between items-start gap-4">
               {event.key_individuals && event.key_individuals.length > 0 && (
                <div className="flex items-start gap-3 text-slate-400">
                  <Users className="h-5 w-5 mt-0.5 shrink-0 text-slate-500" />
                  <p className="text-sm font-medium text-slate-300">
                    {event.key_individuals.length} Key Individual(s)
                  </p>
                </div>
              )}
              {event.ai_assessment_reason && (
                  <p className="text-xs text-slate-500 italic sm:text-right flex-grow">
                    {event.ai_assessment_reason}
                  </p>
              )}
            </div>
        </div>
      </TooltipProvider>

      <AccordionTrigger className="px-4 py-2 text-sm text-slate-400 hover:text-slate-200 hover:no-underline rounded-b-xl bg-black/20 hover:bg-slate-800/50">
        <div className="flex items-center gap-2">
            <FileText className="h-4 w-4" />
            <span>Show {event.source_articles.length || 1} Source Article(s)</span>
        </div>
      </AccordionTrigger>
      <AccordionContent className="p-4 pt-4">
        <div className="space-y-2">
          {event.source_articles.map(article => (
            <a key={article.link} href={article.link} target="_blank" rel="noopener noreferrer" className="block p-3 rounded-md bg-slate-800/50 hover:bg-slate-800/80 transition-colors">
                <p className="font-medium text-slate-200 line-clamp-1 text-sm">{article.headline}</p>
                <p className="text-xs text-slate-400">{article.newspaper}</p>
            </a>
          ))}
        </div>
      </AccordionContent>
    </AccordionItem>
  );
};

# File: src/components/UploadView.jsx
// src/components/UploadView.jsx (version 1.1)
"use client";

import { useState } from 'react';
import { toast } from 'sonner';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Loader2, Wand2, UploadCloud } from 'lucide-react';
import { scrapeAndExtractWithAI } from '@/actions/extract';
import { addKnowledge } from '@/actions/knowledge';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

export function UploadView() {
    const [url, setUrl] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [extractedData, setExtractedData] = useState(null);

    const handleScrape = async () => {
        if (!url || !url.startsWith('http')) {
            toast.error("Please enter a valid, complete URL (e.g., https://...).");
            return;
        }
        setIsLoading(true);
        const result = await scrapeAndExtractWithAI(url);
        setIsLoading(false);

        if (result.success) {
            setExtractedData({
                ...result.data,
                link: url,
            });
            setIsModalOpen(true);
            toast.success("AI Analyst finished extraction!");
        } else {
            toast.error(`Extraction failed: ${result.error}`);
        }
    };

    const handleSave = async () => {
        if (!extractedData.country || !extractedData.publication) {
            toast.error("Please specify both the country and publication before saving.");
            return;
        }

        setIsLoading(true);
        const result = await addKnowledge({
            headline: extractedData.headline,
            business_summary: extractedData.business_summary,
            source: extractedData.publication,
            country: extractedData.country,
            link: extractedData.link,
        });
        setIsLoading(false);
        setIsModalOpen(false);

        if (result.success) {
            toast.success(result.message);
            setUrl('');
            setExtractedData(null);
        } else {
            toast.error(`Failed to save: ${result.message}`);
        }
    };

    return (
        <>
            <div className="max-w-4xl mx-auto">
                <Card className="bg-black/20 backdrop-blur-sm border border-white/10 shadow-2xl shadow-black/30">
                    <CardHeader className="p-8">
                        <CardTitle className="text-2xl">Upload New Knowledge</CardTitle>
                        <CardDescription>
                            Provide an article URL. A specialized AI Analyst will extract the business-critical intelligence for you to review and add to the knowledge base.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="p-8 pt-0">
                        <div className="space-y-2">
                            <Label htmlFor="url" className="text-lg font-semibold">Article URL</Label>
                            <div className="flex gap-4">
                                <Input
                                    id="url"
                                    placeholder="https://example.com/article"
                                    value={url}
                                    onChange={(e) => setUrl(e.target.value)}
                                    disabled={isLoading}
                                    onKeyDown={(e) => e.key === 'Enter' && handleScrape()}
                                    className="h-12 text-base"
                                />
                                <Button onClick={handleScrape} disabled={isLoading} size="lg" className="h-12">
                                    {isLoading ? <Loader2 className="mr-2 h-5 w-5 animate-spin" /> : <Wand2 className="mr-2 h-5 w-5" />}
                                    Analyze & Extract
                                </Button>
                            </div>
                        </div>
                    </CardContent>
                </Card>
            </div>

            <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
                <DialogContent className="sm:max-w-4xl w-[95vw] bg-slate-900 border-slate-700 p-8">
                    <DialogHeader>
                        <DialogTitle className="text-xl">Review AI Analyst's Extraction</DialogTitle>
                        <DialogDescription>
                            The AI has extracted the following intelligence. Please verify the details before adding it to the knowledge base.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="space-y-6 max-h-[70vh] overflow-y-auto p-1 pr-6 custom-scrollbar">
                        <div>
                            <Label className="text-slate-400">Headline</Label>
                            <p className="font-semibold text-lg text-slate-200 mt-1">{extractedData?.headline}</p>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                             <div>
                                <Label htmlFor="modal-publication" className="text-slate-400">Publication *</Label>
                                <Input 
                                    id="modal-publication"
                                    value={extractedData?.publication || ''}
                                    onChange={(e) => setExtractedData(prev => ({...prev, publication: e.target.value}))}
                                    placeholder="e.g., The Financial Times"
                                    className="bg-slate-800 border-slate-600 mt-1 h-10"
                                />
                            </div>
                             <div>
                                <Label htmlFor="modal-country" className="text-slate-400">Country of Origin *</Label>
                                <Input 
                                    id="modal-country"
                                    value={extractedData?.country || ''}
                                    onChange={(e) => setExtractedData(prev => ({...prev, country: e.target.value}))}
                                    placeholder="e.g., Denmark"
                                    className="bg-slate-800 border-slate-600 mt-1 h-10"
                                />
                            </div>
                        </div>
                        <div>
                            <Label className="text-slate-400">Business Summary</Label>
                            <div className="p-4 mt-1 rounded-md bg-slate-800/50 border border-slate-700 text-sm text-slate-300 max-h-72 overflow-y-auto custom-scrollbar">
                                <div className="prose prose-sm prose-invert prose-p:my-2">
                                    <ReactMarkdown remarkPlugins={[remarkGfm]}>
                                        {extractedData?.business_summary}
                                    </ReactMarkdown>
                                </div>
                            </div>
                        </div>
                    </div>
                    <DialogFooter className="pt-6">
                        <Button variant="outline" onClick={() => setIsModalOpen(false)} disabled={isLoading}>Cancel</Button>
                        <Button onClick={handleSave} disabled={isLoading}>
                            {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <UploadCloud className="mr-2 h-4 w-4" />}
                            Add to Knowledge Base
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </>
    );
}

# File: src/components/chat/ChatInput.jsx
// src/components/chat/ChatInput.jsx (version 2.0)
import { Button } from '@/components/ui/button';
import { Send, Loader2 } from 'lucide-react';
import Textarea from 'react-textarea-autosize';

export function ChatInput({ input, handleInputChange, handleSubmit, isLoading, inputRef }) {
    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSubmit(e);
        }
    };

    return (
        <form onSubmit={handleSubmit} className="flex items-end gap-2 p-4 border-t border-white/10">
            <Textarea
                ref={inputRef}
                value={input}
                onChange={handleInputChange}
                onKeyDown={handleKeyDown}
                placeholder="Ask a follow-up question..."
                disabled={isLoading}
                className="flex-grow resize-none bg-slate-900/80 border border-slate-700 rounded-lg shadow-sm p-3 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                minRows={1}
                maxRows={5}
            />
            <Button type="submit" disabled={isLoading || !input.trim()} className="h-12 w-12 flex-shrink-0" size="icon">
                {isLoading ? <Loader2 className="h-5 w-5 animate-spin" /> : <Send className="h-5 w-5" />}
            </Button>
        </form>
    );
}

# File: src/components/chat/ChatMessage.jsx
// src/components/chat/ChatMessage.jsx (version 1.4)
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw'; // Re-import rehype-raw
import { cn } from '@/lib/utils';
import { User, Bot } from 'lucide-react';

const processTaggedContent = (content) => {
    // Replace custom tags with spans that have the correct class.
    // This is done on the string itself before passing it to the Markdown renderer.
    // The rehype-raw plugin will then correctly render these spans inline.
    let processedContent = content.replace(/<rag>/g, '<span class="rag-source">');
    processedContent = processedContent.replace(/<\/rag>/g, '</span>');
    processedContent = processedContent.replace(/<wiki>/g, '<span class="wiki-source">');
    processedContent = processedContent.replace(/<\/wiki>/g, '</span>');
    processedContent = processedContent.replace(/<llm>/g, '<span class="llm-source">');
    processedContent = processedContent.replace(/<\/llm>/g, '</span>');
    return processedContent;
};

export function ChatMessage({ message }) {
  const isUser = message.role === 'user';
  
  return (
    <div className={cn('flex items-start gap-4', isUser && 'justify-end')}>
      {!isUser && (
        <div className="flex-shrink-0 w-8 h-8 rounded-full bg-blue-500/20 text-blue-300 flex items-center justify-center">
          <Bot className="h-5 w-5" />
        </div>
      )}
      <div className={cn(
          'px-4 py-3 rounded-xl max-w-[85%]',
          isUser ? 'bg-slate-700' : 'bg-slate-800'
      )}>
        <div className="overflow-x-auto custom-scrollbar">
            <div className="prose prose-sm prose-invert max-w-none prose-p:my-1 prose-headings:my-2 prose-ul:my-2 prose-li:my-0 text-slate-200">
                {isUser ? (
                    <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeRaw]}>
                        {message.content}
                    </ReactMarkdown>
                ) : (
                    <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeRaw]}>
                        {processTaggedContent(message.content)}
                    </ReactMarkdown>
                )}
            </div>
        </div>
      </div>
      {isUser && (
        <div className="flex-shrink-0 w-8 h-8 rounded-full bg-slate-500/20 text-slate-300 flex items-center justify-center">
          <User className="h-5 w-5" />
        </div>
      )}
    </div>
  );
}

# File: src/components/chat/ChatScrollAnchor.jsx
"use client";

import { useRef, useEffect } from "react";

export function ChatScrollAnchor({ messages }) {
  const scrollAnchorRef = useRef(null);

  useEffect(() => {
    if (scrollAnchorRef.current) {
        scrollAnchorRef.current.scrollIntoView({
            block: "start",
            behavior: "smooth",
      });
    }
  }, [messages]); // Trigger scroll whenever messages array changes

  return <div ref={scrollAnchorRef} className="h-px w-full" />;
}

# File: src/components/chat/ChatSidebar.jsx
// src/components/chat/ChatSidebar.jsx (version 1.0)
"use client";

import { Button } from '@/components/ui/button';
import { PlusCircle, MessageSquare } from 'lucide-react';
import { cn } from '@/lib/utils';

export function ChatSidebar({ chats, activeChatId, createChat, selectChat }) {
    return (
        <div className="flex flex-col h-full bg-slate-900/50 border-r border-slate-700/50 p-2">
            <Button onClick={createChat} className="mb-4">
                <PlusCircle className="mr-2 h-4 w-4" />
                New Chat
            </Button>
            <div className="flex-grow overflow-y-auto custom-scrollbar pr-1">
                <div className="flex flex-col gap-1">
                    {chats.map(chat => (
                        <Button
                            key={chat.id}
                            variant="ghost"
                            onClick={() => selectChat(chat.id)}
                            className={cn(
                                "w-full justify-start text-left truncate",
                                activeChatId === chat.id && "bg-blue-500/20 text-blue-200"
                            )}
                        >
                            <MessageSquare className="mr-2 h-4 w-4 flex-shrink-0" />
                            <span className="truncate">{chat.title}</span>
                        </Button>
                    ))}
                </div>
            </div>
        </div>
    );
}

# File: src/components/chat/ChatThinkingIndicator.jsx
import { Sparkles } from 'lucide-react';

export function ChatThinkingIndicator({ status }) {
  return (
    <div className="flex items-center gap-3 text-sm text-slate-400">
      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-slate-700/50 flex items-center justify-center">
        <Sparkles className="h-5 w-5 text-yellow-400 animate-pulse" />
      </div>
      <div className="p-2 rounded-lg">
        <p className="italic">{status}</p>
      </div>
    </div>
  );
}

# File: src/components/ui/accordion.jsx
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />;
}

function AccordionItem({
  className,
  ...props
}) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props} />
  );
}

function AccordionTrigger({
  className,
  children,
  ...props
}) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}>
        {children}
        <ChevronDownIcon
          className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  );
}

function AccordionContent({
  className,
  children,
  ...props
}) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}>
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  );
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


# File: src/components/ui/alert-dialog.jsx
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

# File: src/components/ui/badge.jsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props} />
  );
}

export { Badge, badgeVariants }


# File: src/components/ui/button.jsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props} />
  );
}

export { Button, buttonVariants }


# File: src/components/ui/card.jsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({
  className,
  ...props
}) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props} />
  );
}

function CardHeader({
  className,
  ...props
}) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props} />
  );
}

function CardTitle({
  className,
  ...props
}) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props} />
  );
}

function CardDescription({
  className,
  ...props
}) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props} />
  );
}

function CardAction({
  className,
  ...props
}) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props} />
  );
}

function CardContent({
  className,
  ...props
}) {
  return (<div data-slot="card-content" className={cn("px-6", className)} {...props} />);
}

function CardFooter({
  className,
  ...props
}) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props} />
  );
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


# File: src/components/ui/dialog.jsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

# File: src/components/ui/input.jsx
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({
  className,
  type,
  ...props
}) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props} />
  );
}

export { Input }


# File: src/components/ui/label.jsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props} />
  );
}

export { Label }


# File: src/components/ui/select.jsx
// src/components/ui/select.jsx (version 1.1)
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({
  ...props
}) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({
  ...props
}) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}>
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md bg-slate-900 border-slate-700",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}>
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn("p-1", position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1")}>
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectLabel({
  className,
  ...props
}) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props} />
  );
}

function SelectItem({
  className,
  children,
  ...props
}) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}>
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({
  className,
  ...props
}) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props} />
  );
}

function SelectScrollUpButton({
  className,
  ...props
}) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}>
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

# File: src/components/ui/sonner.jsx
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

const Toaster = ({
  ...props
}) => {
  // Hardcoding theme to 'dark' as the app is dark-only.
  // If you ever add a light theme, you can use the useTheme hook from next-themes.
  const theme = "dark";

  return (
    (<Sonner
      theme={theme}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props} />)
  );
}

export { Toaster }

# File: src/components/ui/tabs.jsx
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

# File: src/components/ui/tooltip.jsx
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

# File: src/config/constants.js
// Pagination settings
export const ARTICLES_PER_PAGE = 10;
export const EVENTS_PER_PAGE = 5;


# File: src/hooks/use-debounce.js
"use client";

import { useState, useEffect } from 'react';

// No changes needed, but provided for completeness as it's used by the updated Filters component.
export function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

# File: src/hooks/use-has-hydrated.js
// src/hooks/use-has-hydrated.js (version 1.0)
"use client";

import { useState, useEffect } from 'react';
import { useAppStore } from '@/store/use-app-store';

/**
 * A hook that returns `true` only after the Zustand store has been rehydrated
 * from localStorage on the client.
 * @returns {boolean} - `true` if hydrated, `false` otherwise.
 */
export function useHasHydrated() {
  const [hydrated, setHydrated] = useState(false);

  useEffect(() => {
    // The `persist.onFinishHydration` listener is the key. It's a reliable
    // event fired by the middleware precisely when rehydration is complete.
    const unsubFinishHydration = useAppStore.persist.onFinishHydration(() => {
      setHydrated(true);
    });

    // Also set hydrated to true if the store is already hydrated,
    // which can happen on subsequent navigations.
    if (useAppStore.persist.hasHydrated()) {
      setHydrated(true);
    }

    return () => {
      unsubFinishHydration();
    };
  }, []);

  return hydrated;
}

# File: src/hooks/use-local-storage.js
"use client";

import { useState, useEffect, useCallback } from 'react';

export function useLocalStorage(key, initialValue) {
    const [storedValue, setStoredValue] = useState(initialValue);

    useEffect(() => {
        // This check ensures localStorage is only accessed on the client side.
        if (typeof window === 'undefined') {
            return;
        }
        try {
            const item = window.localStorage.getItem(key);
            if (item) {
                setStoredValue(JSON.parse(item));
            }
        } catch (error) {
            console.error(`Error reading localStorage key “${key}”:`, error);
        }
    }, [key]);

    const setValue = useCallback((value) => {
        if (typeof window === 'undefined') {
            console.warn(`Tried to set localStorage key “${key}” on the server`);
            return;
        }
        try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
            console.error(`Error setting localStorage key “${key}”:`, error);
        }
    }, [key, storedValue]);
    
    return [storedValue, setValue];
}

# File: src/hooks/use-push-manager.js
// src/hooks/use-push-manager.js (version 3.0)
"use client";

import { useState, useEffect, useCallback } from 'react';
import { toast } from 'sonner';

function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

export function usePushManager() {
    const [isSupported, setIsSupported] = useState(false);
    const [isSubscribed, setIsSubscribed] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [swRegistration, setSwRegistration] = useState(null);

    useEffect(() => {
        if (typeof window !== 'undefined' && 'serviceWorker' in navigator && 'PushManager' in window) {
            console.log("[PushManager] Browser supports Service Workers and Push.");
            setIsSupported(true);

            // --- DEFINITIVE PATTERN: Wait for the Service Worker to be ready, with a timeout ---
            const initializePushManager = async () => {
                try {
                    // The `navigator.serviceWorker.ready` promise resolves when the service worker
                    // is active and controlling the page. This is the most reliable signal.
                    const readyPromise = navigator.serviceWorker.ready;
                    
                    // Create a timeout promise to prevent getting stuck indefinitely.
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error("Service Worker readiness check timed out after 5 seconds.")), 5000)
                    );

                    // Race the two promises. Whichever finishes first wins.
                    const registration = await Promise.race([readyPromise, timeoutPromise]);
                    
                    console.log("[PushManager] Service Worker is active and ready:", registration);
                    setSwRegistration(registration);
                    
                    const subscription = await registration.pushManager.getSubscription();
                    console.log("[PushManager] Initial subscription state:", subscription);
                    setIsSubscribed(!!subscription);

                } catch (error) {
                    console.error("[PushManager] Initialization failed:", error);
                    toast.error("Notification service failed.", { description: error.message });
                    setIsSupported(false); // Gracefully disable the feature
                } finally {
                    setIsLoading(false);
                }
            };

            initializePushManager();
        } else {
            console.log("[PushManager] Browser does not support Service Workers or Push.");
            setIsSupported(false);
            setIsLoading(false);
        }
    }, []);

    const subscribe = useCallback(async () => {
        if (!swRegistration) {
            toast.error("Service Worker not ready *).", { description: "The background service for notifications is still starting. Please try again in a moment." });
            return false;
        }

        const VAPID_PUBLIC_KEY = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY;
        if (!VAPID_PUBLIC_KEY) {
            toast.error("Push notifications are not configured on the server.");
            return false;
        }

        if (Notification.permission === 'denied') {
            toast.error("Notification permission has been denied.", {
                description: "You must enable notifications for this site in your browser settings.",
            });
            return false;
        }

        setIsLoading(true);
        try {
            const subscription = await swRegistration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
            });
            console.log("[PushManager] New subscription created:", subscription);

            await fetch('/api/push/subscribe', {
                method: 'POST',
                body: JSON.stringify(subscription),
                headers: { 'Content-Type': 'application/json' },
            });
            console.log("[PushManager] Subscription sent to server.");

            setIsSubscribed(true);
            toast.success("Notifications enabled!");
            return true;
        } catch (error) {
            console.error("[PushManager] Full subscription error object:", error);
            
            let errorMessage = "An unexpected error occurred.";
            if (error instanceof Error) {
                errorMessage = `${error.name}: ${error.message}`;
            }

            if (error.name === 'NotAllowedError') {
                 toast.error("Permission denied.", { description: "You did not grant permission for notifications." });
            } else {
                 toast.error("Failed to enable notifications.", { description: errorMessage });
            }
            return false;
        } finally {
            setIsLoading(false);
        }
    }, [swRegistration]);

    return { isSupported, isSubscribed, isLoading, subscribe };
}

# File: src/hooks/use-realtime-updates.js
// src/hooks/use-realtime-updates.js (version 1.0)
"use client";

import { useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import Pusher from 'pusher-js';
import { toast } from 'sonner';

export function useRealtimeUpdates() {
    const router = useRouter();
    // Use a ref to prevent re-subscribing on every render
    const pusherRef = useRef(null);
    const channelRef = useRef(null);

    useEffect(() => {
        // Ensure this only runs once and on the client
        if (pusherRef.current) return;

        const PUSHER_KEY = process.env.NEXT_PUBLIC_PUSHER_KEY;
        const PUSHER_CLUSTER = process.env.NEXT_PUBLIC_PUSHER_CLUSTER;

        if (!PUSHER_KEY || !PUSHER_CLUSTER) {
            console.warn("Pusher keys not found, real-time updates are disabled.");
            return;
        }

        try {
            pusherRef.current = new Pusher(PUSHER_KEY, {
                cluster: PUSHER_CLUSTER
            });
    
            channelRef.current = pusherRef.current.subscribe('data-updates');
    
            channelRef.current.bind('data-changed', (data) => {
                console.log('Real-time event received:', data);
                toast.info("New intelligence has been added.", {
                    description: "The view will now refresh automatically.",
                    action: {
                        label: 'Refresh Now',
                        onClick: () => router.refresh(),
                    },
                });
                // Soft-refresh the page to get new server-rendered data
                router.refresh(); 
            });

            console.log("Successfully subscribed to real-time updates channel.");

        } catch (error) {
            console.error("Failed to initialize Pusher:", error);
        }

        // Cleanup on component unmount
        return () => {
            if (pusherRef.current) {
                pusherRef.current.unsubscribe('data-updates');
                pusherRef.current.disconnect();
                pusherRef.current = null;
            }
        };
    }, [router]); // router is stable
}

# File: src/lib/countries.js
// A map of country names to their flag emojis.
const countryFlagMap = {
  'denmark': '🇩🇰',
  'norway': '🇳🇴',
  'sweden': '🇸🇪',
  'finland': '🇫🇮',
  'netherlands': '🇳🇱',
  'belgium': '🇧🇪',
  'united states': '🇺🇸',
  'united kingdom': '🇬🇧',
  'germany': '🇩🇪',
  'switzerland': '🇨🇭',
  // Special categories from your backend
  'global pe': '🌐',
  'm&a aggregators': '🤝',
};

const defaultFlag = '🌍'; // Fallback for any country not in the map

/**
 * Returns the flag emoji for a given country name in a case-insensitive manner.
 * @param {string | null | undefined} countryName - The name of the country (e.g., "Denmark").
 * @returns {string} The corresponding flag emoji.
 */
export function getCountryFlag(countryName) {
  if (!countryName) return defaultFlag;
  const normalizedName = countryName.trim().toLowerCase();
  return countryFlagMap[normalizedName] || defaultFlag;
}

// You can expand this list as needed
export const COMMON_COUNTRIES = [
    "Denmark",
    "Sweden",
    "Norway",
    "Finland",
    "Netherlands",
    "United Kingdom",
    "United States",
    "Germany",
    "Switzerland",
];

# File: src/lib/embeddings.js
// src/lib/embeddings.js (Enhanced version with query expansion and caching)
"use server";
import { pipeline } from '@xenova/transformers';

// In-memory cache for embeddings (consider Redis for production)
const embeddingCache = new Map();
const MAX_CACHE_SIZE = 1000;

// Singleton pattern to ensure we only load the model once per server instance
class EmbeddingPipeline {
    static task = 'feature-extraction';
    static model = 'Xenova/all-MiniLM-L6-v2';
    static instance = null;
    
    static async getInstance() {
        if (this.instance === null) {
            const { pipeline } = await import('@xenova/transformers');
            this.instance = await pipeline(this.task, this.model);
        }
        return this.instance;
    }
}

/**
 * Creates a cache key from text
 * @param {string} text 
 * @returns {string}
 */
function createCacheKey(text) {
    return `embed_${text.toLowerCase().trim().replace(/\s+/g, '_')}`;
}

/**
 * Manages cache size to prevent memory bloat
 */
function manageCacheSize() {
    if (embeddingCache.size >= MAX_CACHE_SIZE) {
        // Remove oldest 20% of entries (FIFO-ish)
        const keysToRemove = Array.from(embeddingCache.keys()).slice(0, Math.floor(MAX_CACHE_SIZE * 0.2));
        keysToRemove.forEach(key => embeddingCache.delete(key));
        console.log(`[Embedding Cache] Cleaned ${keysToRemove.length} entries`);
    }
}

/**
 * Generates an embedding for a given text with caching
 * @param {string} text The text to embed
 * @returns {Promise<Array<number>>} A promise that resolves to the embedding vector
 */
export async function generateEmbedding(text) {
    if (!text || text.trim().length === 0) {
        throw new Error('Text cannot be empty for embedding generation');
    }
    
    const cleanText = text.trim();
    const cacheKey = createCacheKey(cleanText);
    
    // Check cache first
    if (embeddingCache.has(cacheKey)) {
        console.log(`[Embedding Cache] Hit for text: "${cleanText.substring(0, 50)}..."`);
        return embeddingCache.get(cacheKey);
    }
    
    try {
        const extractor = await EmbeddingPipeline.getInstance();
        const output = await extractor(cleanText, { pooling: 'mean', normalize: true });
        const embedding = Array.from(output.data);
        
        // Cache the result
        manageCacheSize();
        embeddingCache.set(cacheKey, embedding);
        
        console.log(`[Embedding] Generated embedding for text: "${cleanText.substring(0, 50)}..." (${embedding.length} dimensions)`);
        return embedding;
        
    } catch (error) {
        console.error(`[Embedding Error] Failed to generate embedding: ${error.message}`);
        throw new Error(`Failed to generate embedding: ${error.message}`);
    }
}

/**
 * Generates multiple query variations to improve RAG recall
 * @param {string} originalQuery 
 * @returns {Promise<Array<Array<number>>>} Array of embeddings for different query variations
 */
export async function generateQueryEmbeddings(originalQuery) {
    const variations = generateQueryVariations(originalQuery);
    const embeddingPromises = variations.map(query => generateEmbedding(query));
    
    try {
        const embeddings = await Promise.all(embeddingPromises);
        console.log(`[Query Expansion] Generated ${embeddings.length} query variations for: "${originalQuery}" ->`, variations);
        return embeddings;
    } catch (error) {
        console.error(`[Query Expansion Error] ${error.message}`);
        // Fallback to original query only
        return [await generateEmbedding(originalQuery)];
    }
}

/**
 * Creates query variations to improve semantic search recall
 * @param {string} query 
 * @returns {Array<string>}
 */
function generateQueryVariations(query) {
    const originalQuery = query.trim();
    const variations = new Set([originalQuery]);

    // CORRECTED: Smartly strip disambiguation tags for broader searches
    const coreEntity = originalQuery.replace(/\s*\((company|person)\)$/, '').trim();
    if (coreEntity !== originalQuery) {
        variations.add(coreEntity);
    }

    // Pattern for "Who founded X?"
    const हूंFounderMatch = coreEntity.toLowerCase().match(/^(?:who|what)\s+(?:is|was|founded|created)\s+(.+)/);
    if ( हूंFounderMatch) {
        let subject = हूंFounderMatch[1].replace(/\?/g, '').replace(/^(the|a|an)\s/,'').trim();
        variations.add(subject);
        variations.add(`${subject} founder`);
        variations.add(`founder of ${subject}`);
        variations.add(`${subject} history`);
    } else {
        // General question pattern
        const questionMatch = coreEntity.toLowerCase().match(/^(who|what|when|where|why|how)\s(is|are|was|were|did|does|do)\s(.+)/);
        if (questionMatch) {
            let subject = questionMatch[3].replace(/\?/g, '').trim();
            variations.add(subject);
            
            const simplified = subject.replace(/^(the|a|an)\s/,'').split(' of ');
            if (simplified.length > 1) {
                variations.add(`${simplified[1].trim()} ${simplified[0].trim()}`);
            }
        }
    }
    
    // Add generic variations for the core entity
    if (hasProperNouns(coreEntity)) {
        variations.add(`${coreEntity} background details`);
        variations.add(`Information about ${coreEntity}`);
    }
    
    // Return the top 4 most distinct variations
    return Array.from(variations).slice(0, 4);
}


/**
 * Simple check for proper nouns (capitalized words not at the start of a sentence)
 * @param {string} text 
 * @returns {boolean}
 */
function hasProperNouns(text) {
    // Looks for words starting with an uppercase letter
    return /\b[A-Z][a-z]+/.test(text);
}

/**
 * Batch embedding generation for efficiency
 * @param {Array<string>} texts 
 * @returns {Promise<Array<Array<number>>>}
 */
export async function generateBatchEmbeddings(texts) {
    if (!texts || texts.length === 0) {
        return [];
    }
    
    const embeddings = [];
    const extractor = await EmbeddingPipeline.getInstance();
    
    // Process in batches to avoid memory issues
    const BATCH_SIZE = 10;
    for (let i = 0; i < texts.length; i += BATCH_SIZE) {
        const batch = texts.slice(i, i + BATCH_SIZE);
        const batchPromises = batch.map(text => {
            const cacheKey = createCacheKey(text);
            if (embeddingCache.has(cacheKey)) {
                return Promise.resolve(embeddingCache.get(cacheKey));
            }
            return extractor(text, { pooling: 'mean', normalize: true })
                .then(output => {
                    const embedding = Array.from(output.data);
                    embeddingCache.set(cacheKey, embedding);
                    return embedding;
                });
        });
        
        const batchEmbeddings = await Promise.all(batchPromises);
        embeddings.push(...batchEmbeddings);
        
        console.log(`[Batch Embedding] Processed batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(texts.length/BATCH_SIZE)}`);
    }
    
    return embeddings;
}

/**
 * Calculate cosine similarity between two embeddings
 * @param {Array<number>} embedding1 
 * @param {Array<number>} embedding2 
 * @returns {Promise<number>} Similarity score between 0 and 1
 */
export async function calculateSimilarity(embedding1, embedding2) {
    if (embedding1.length !== embedding2.length) {
        throw new Error('Embeddings must have the same dimensions');
    }
    
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    
    for (let i = 0; i < embedding1.length; i++) {
        dotProduct += embedding1[i] * embedding2[i];
        norm1 += embedding1[i] * embedding1[i];
        norm2 += embedding2[i] * embedding2[i];
    }
    
    if (norm1 === 0 || norm2 === 0) return 0;
    
    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
}

/**
 * Get cache statistics for monitoring
 * @returns {Promise<Object>}
 */
export async function getCacheStats() {
    return {
        size: embeddingCache.size,
        maxSize: MAX_CACHE_SIZE,
        utilizationPercent: Math.round((embeddingCache.size / MAX_CACHE_SIZE) * 100)
    };
}

# File: src/lib/env.js
import { z } from "zod";

const envSchema = z.object({
  MONGO_URI: z.string().url(),
  // Add other environment variables here as your app grows
  // e.g., NEXT_PUBLIC_API_URL: z.string().url(),
});

export const env = envSchema.parse(process.env);

    

# File: src/lib/mongodb.js
import mongoose from 'mongoose';
import { env } from '@/lib/env'; // Use the validated environment variables

const MONGO_URI = env.MONGO_URI;

if (!MONGO_URI) {
  // This check is now redundant due to Zod, but good for clarity.
  throw new Error(
    'Please define the MONGO_URI environment variable inside .env or .env.local'
  );
}

/**
 * Global is used here to maintain a cached connection across hot reloads
 * in development. This prevents connections from growing exponentially
 * during API Route usage.
 */
let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGO_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }
  
  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

# File: src/lib/monitoring.js
// src/lib/monitoring.js - Monitoring and analytics for RAG performance
"use server";

// In-memory analytics store (use Redis/database in production)
const analyticsStore = {
    queries: [],
    performance: {},
    errors: []
};

/**
 * Logs a query and its performance metrics
 * @param {Object} queryData 
 */
export async function logQuery(queryData) {
    const timestamp = Date.now();
    const entry = {
        timestamp,
        query: queryData.query,
        entities: queryData.entities,
        ragResults: queryData.ragResults?.length || 0,
        wikiResults: queryData.wikiResults?.length || 0,
        maxSimilarity: queryData.maxSimilarity || 0,
        qualityScore: queryData.qualityScore || 0,
        responseTime: queryData.responseTime || 0,
        confidenceLevel: queryData.confidenceLevel || 'unknown',
        hadHallucinations: queryData.hadHallucinations || false,
        sourceConflicts: queryData.sourceConflicts || 0
    };
    
    analyticsStore.queries.push(entry);
    
    // Keep only last 1000 queries to prevent memory bloat
    if (analyticsStore.queries.length > 1000) {
        analyticsStore.queries = analyticsStore.queries.slice(-1000);
    }
    
    console.log(`[Analytics] Logged query: ${queryData.query.substring(0, 50)}...`);
}

/**
 * Logs performance metrics
 * @param {string} operation 
 * @param {number} duration 
 * @param {Object} metadata 
 */
export async function logPerformance(operation, duration, metadata = {}) {
    if (!analyticsStore.performance[operation]) {
        analyticsStore.performance[operation] = {
            count: 0,
            totalTime: 0,
            averageTime: 0,
            minTime: Infinity,
            maxTime: 0,
            errors: 0
        };
    }
    
    const perf = analyticsStore.performance[operation];
    perf.count++;
    perf.totalTime += duration;
    perf.averageTime = perf.totalTime / perf.count;
    perf.minTime = Math.min(perf.minTime, duration);
    perf.maxTime = Math.max(perf.maxTime, duration);
    
    if (metadata.error) {
        perf.errors++;
    }
}

/**
 * Gets analytics dashboard data
 * @returns {Promise<Object>} Analytics summary
 */
export async function getAnalyticsDashboard() {
    const recentQueries = analyticsStore.queries.slice(-100);
    const last24Hours = analyticsStore.queries.filter(q => 
        Date.now() - q.timestamp < 24 * 60 * 60 * 1000
    );
    
    return {
        overview: {
            totalQueries: analyticsStore.queries.length,
            queriesLast24h: last24Hours.length,
            averageQualityScore: calculateAverage(recentQueries, 'qualityScore'),
            averageResponseTime: calculateAverage(recentQueries, 'responseTime'),
            hallucinationRate: calculateRate(recentQueries, 'hadHallucinations'),
            highConfidenceRate: calculateRate(recentQueries, q => q.confidenceLevel === 'high')
        },
        qualityMetrics: {
            averageRAGResults: calculateAverage(recentQueries, 'ragResults'),
            averageWikiResults: calculateAverage(recentQueries, 'wikiResults'),
            averageSimilarity: calculateAverage(recentQueries, 'maxSimilarity'),
            sourceConflictRate: calculateRate(recentQueries, q => q.sourceConflicts > 0)
        },
        performance: analyticsStore.performance,
        trends: calculateTrends(analyticsStore.queries),
        commonIssues: identifyCommonIssues(recentQueries)
    };
}

/**
 * Identifies patterns that might indicate hallucination risks
 * @param {Array} queries 
 * @returns {Promise<Array>} Risk indicators
 */
export async function identifyHallucinationRisks(queries = analyticsStore.queries.slice(-100)) {
    const risks = [];
    
    // Low similarity threshold
    const lowSimilarityQueries = queries.filter(q => q.maxSimilarity < 0.3);
    if (lowSimilarityQueries.length / queries.length > 0.2) {
        risks.push({
            type: 'low_similarity',
            severity: 'medium',
            description: `${Math.round(lowSimilarityQueries.length / queries.length * 100)}% of queries have very low similarity scores`,
            recommendation: 'Consider improving embedding model or expanding knowledge base'
        });
    }
    
    // High hallucination rate
    const hallucinatedQueries = queries.filter(q => q.hadHallucinations);
    if (hallucinatedQueries.length / queries.length > 0.1) {
        risks.push({
            type: 'high_hallucination_rate',
            severity: 'high',
            description: `${Math.round(hallucinatedQueries.length / queries.length * 100)}% of queries had detected hallucinations`,
            recommendation: 'Review and strengthen hallucination detection system'
        });
    }
    
    // Frequent source conflicts
    const conflictQueries = queries.filter(q => q.sourceConflicts > 0);
    if (conflictQueries.length / queries.length > 0.15) {
        risks.push({
            type: 'source_conflicts',
            severity: 'medium',
            description: `${Math.round(conflictQueries.length / queries.length * 100)}% of queries had source conflicts`,
            recommendation: 'Review data sources for consistency and accuracy'
        });
    }
    
    return risks;
}

/**
 * Generates recommendations for system improvements
 * @returns {Promise<Array>} Improvement recommendations
 */
export async function generateSystemRecommendations() {
    const dashboard = await getAnalyticsDashboard();
    const risks = await identifyHallucinationRisks();
    const recommendations = [];
    
    // Performance recommendations
    if (dashboard.overview.averageResponseTime > 3000) {
        recommendations.push({
            category: 'performance',
            priority: 'high',
            title: 'Slow Response Times',
            description: `Average response time is ${(dashboard.overview.averageResponseTime / 1000).toFixed(1)}s`,
            actions: [
                'Implement embedding caching',
                'Optimize Pinecone query parameters',
                'Consider parallel processing improvements'
            ]
        });
    }
    
    // Quality recommendations
    if (dashboard.overview.averageQualityScore < 0.7) {
        recommendations.push({
            category: 'quality',
            priority: 'high',
            title: 'Low Quality Scores',
            description: `Average quality score is ${dashboard.overview.averageQualityScore.toFixed(2)}`,
            actions: [
                'Improve source material quality',
                'Enhance entity extraction',
                'Strengthen validation rules'
            ]
        });
    }
    
    // Coverage recommendations
    if (dashboard.qualityMetrics.averageRAGResults < 2) {
        recommendations.push({
            category: 'coverage',
            priority: 'medium',
            title: 'Low RAG Result Coverage',
            description: `Average RAG results per query: ${dashboard.qualityMetrics.averageRAGResults.toFixed(1)}`,
            actions: [
                'Expand knowledge base',
                'Implement query expansion',
                'Lower similarity threshold for broader matching'
            ]
        });
    }
    
    // Add risk-based recommendations
    risks.forEach(risk => {
        recommendations.push({
            category: 'risk_mitigation',
            priority: risk.severity,
            title: risk.type.replace('_', ' ').toUpperCase(),
            description: risk.description,
            actions: [risk.recommendation]
        });
    });
    
    return recommendations.sort((a, b) => {
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
    });
}

/**
 * Exports analytics data for external analysis
 * @param {string} format - 'json' or 'csv'
 * @returns {Promise<string>} Formatted data
 */
export async function exportAnalytics(format = 'json') {
    const data = {
        exportTime: new Date().toISOString(),
        dashboard: await getAnalyticsDashboard(),
        risks: await identifyHallucinationRisks(),
        recommendations: await generateSystemRecommendations(),
        rawQueries: analyticsStore.queries.slice(-500) // Last 500 queries
    };
    
    if (format === 'json') {
        return JSON.stringify(data, null, 2);
    }
    
    if (format === 'csv') {
        const csvRows = [
            'timestamp,query,ragResults,wikiResults,maxSimilarity,qualityScore,responseTime,confidenceLevel,hadHallucinations,sourceConflicts'
        ];
        
        data.rawQueries.forEach(query => {
            csvRows.push([
                new Date(query.timestamp).toISOString(),
                `"${query.query.replace(/"/g, '""')}"`,
                query.ragResults,
                query.wikiResults,
                query.maxSimilarity.toFixed(3),
                query.qualityScore.toFixed(3),
                query.responseTime,
                query.confidenceLevel,
                query.hadHallucinations,
                query.sourceConflicts
            ].join(','));
        });
        
        return csvRows.join('\n');
    }
    
    throw new Error(`Unsupported export format: ${format}`);
}

/**
 * Real-time monitoring for alert conditions
 * @returns {Promise<Array>} Active alerts
 */
export async function checkAlerts() {
    const alerts = [];
    const recentQueries = analyticsStore.queries.slice(-50); // Last 50 queries
    
    if (recentQueries.length === 0) return alerts;
    
    // High error rate alert
    const recentErrors = recentQueries.filter(q => q.qualityScore < 0.5).length;
    if (recentErrors / recentQueries.length > 0.3) {
        alerts.push({
            type: 'high_error_rate',
            severity: 'critical',
            message: `${Math.round(recentErrors / recentQueries.length * 100)}% of recent queries had low quality scores`,
            timestamp: Date.now()
        });
    }
    
    // Performance degradation alert
    const recentAvgTime = calculateAverage(recentQueries, 'responseTime');
    const historicalAvgTime = calculateAverage(analyticsStore.queries.slice(-200, -50), 'responseTime');
    
    if (recentAvgTime > historicalAvgTime * 1.5 && recentAvgTime > 2000) {
        alerts.push({
            type: 'performance_degradation',
            severity: 'warning',
            message: `Response time increased by ${Math.round((recentAvgTime / historicalAvgTime - 1) * 100)}%`,
            timestamp: Date.now()
        });
    }
    
    // Hallucination spike alert
    const recentHallucinations = recentQueries.filter(q => q.hadHallucinations).length;
    if (recentHallucinations > 5) {
        alerts.push({
            type: 'hallucination_spike',
            severity: 'critical',
            message: `${recentHallucinations} hallucinations detected in last 50 queries`,
            timestamp: Date.now()
        });
    }
    
    return alerts;
}

/**
 * Clears old analytics data
 * @param {number} daysToKeep 
 */
export async function cleanupAnalytics(daysToKeep = 30) {
    const cutoffTime = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);
    const initialCount = analyticsStore.queries.length;
    
    analyticsStore.queries = analyticsStore.queries.filter(q => q.timestamp > cutoffTime);
    analyticsStore.errors = analyticsStore.errors.filter(e => e.timestamp > cutoffTime);
    
    const removedCount = initialCount - analyticsStore.queries.length;
    console.log(`[Analytics Cleanup] Removed ${removedCount} old entries, keeping ${analyticsStore.queries.length} recent entries`);
    
    return { removed: removedCount, remaining: analyticsStore.queries.length };
}

// Helper functions

function calculateAverage(array, property) {
    if (array.length === 0) return 0;
    const sum = array.reduce((acc, item) => {
        const value = typeof property === 'string' ? item[property] : property(item);
        return acc + (value || 0);
    }, 0);
    return sum / array.length;
}

function calculateRate(array, condition) {
    if (array.length === 0) return 0;
    const matches = array.filter(item => 
        typeof condition === 'string' ? item[condition] : condition(item)
    ).length;
    return matches / array.length;
}

function calculateTrends(queries) {
    if (queries.length < 10) return {};
    
    const periods = [
        { name: 'last_hour', ms: 60 * 60 * 1000 },
        { name: 'last_day', ms: 24 * 60 * 60 * 1000 },
        { name: 'last_week', ms: 7 * 24 * 60 * 60 * 1000 }
    ];
    
    const trends = {};
    const now = Date.now();
    
    periods.forEach(period => {
        const periodQueries = queries.filter(q => now - q.timestamp <= period.ms);
        if (periodQueries.length > 0) {
            trends[period.name] = {
                count: periodQueries.length,
                avgQuality: calculateAverage(periodQueries, 'qualityScore'),
                avgSimilarity: calculateAverage(periodQueries, 'maxSimilarity'),
                hallucinationRate: calculateRate(periodQueries, 'hadHallucinations')
            };
        }
    });
    
    return trends;
}

function identifyCommonIssues(queries) {
    const issues = [];
    
    // Analyze query patterns
    const queryTypes = {};
    const entityCounts = {};
    
    queries.forEach(query => {
        // Categorize query types
        const queryText = query.query.toLowerCase();
        let category = 'general';
        
        if (queryText.includes('what is') || queryText.includes('who is')) {
            category = 'definition';
        } else if (queryText.includes('how much') || queryText.includes('worth') || queryText.includes('revenue')) {
            category = 'financial';
        } else if (queryText.includes('when') || queryText.includes('history')) {
            category = 'historical';
        }
        
        queryTypes[category] = (queryTypes[category] || 0) + 1;
        
        // Track entity extraction success
        if (query.entities && query.entities.length > 0) {
            entityCounts[query.entities.length] = (entityCounts[query.entities.length] || 0) + 1;
        }
    });
    
    // Identify problematic patterns
    const lowQualityQueries = queries.filter(q => q.qualityScore < 0.6);
    if (lowQualityQueries.length > queries.length * 0.2) {
        issues.push({
            type: 'quality',
            description: `${Math.round(lowQualityQueries.length / queries.length * 100)}% of queries have quality issues`,
            severity: 'medium',
            affectedQueries: lowQualityQueries.length
        });
    }
    
    const noRAGResults = queries.filter(q => q.ragResults === 0);
    if (noRAGResults.length > queries.length * 0.3) {
        issues.push({
            type: 'coverage',
            description: `${Math.round(noRAGResults.length / queries.length * 100)}% of queries found no RAG results`,
            severity: 'high',
            affectedQueries: noRAGResults.length
        });
    }
    
    return issues;
}

/**
 * Performance monitoring middleware
 * @param {string} operation 
 * @returns {Object} Timer object with end function
 */
export async function startTimer(operation) {
    const startTime = Date.now();
    return {
        end: async (metadata = {}) => {
            const duration = Date.now() - startTime;
            await logPerformance(operation, duration, metadata);
            return duration;
        }
    };
}

# File: src/lib/rag/generation.js
// src/lib/rag/generation.js (version 1.0)
import OpenAI from 'openai';
import { OpenAIStream, StreamingTextResponse } from 'ai';
import { getGeneratorPrompt, INSUFFICIENT_DATA_PROMPT } from './prompts';
import { generateConfidenceDisclaimer } from './validation';

// --- Client & Model ---
const groq = new OpenAI({ apiKey: process.env.GROQ_API_KEY, baseURL: 'https://api.groq.com/openai/v1' });
const GENERATION_MODEL = 'openai/gpt-oss-120b';

function assembleContext(ragResults, wikiResults, rewrittenQuery, contextQuality, sourceValidation) {
    const dbContext = ragResults.length > 0 
        ? ragResults.map(match => `- [Similarity: ${match.score.toFixed(3)}] ${match.metadata.headline}: ${match.metadata.summary}`).join('\n')
        : null;
    
    const wikiContext = wikiResults.length > 0
        ? wikiResults.map(res => `- [Quality: ${res.validation.quality}] ${res.title}: ${res.summary}`).join('\n')
        : null;

    return `Context Quality Assessment:
- Internal Database: ${contextQuality.ragResultCount} documents (max similarity: ${contextQuality.maxSimilarity.toFixed(3)})
- Wikipedia: ${contextQuality.wikiResultCount} high-quality articles
- Confidence Level: ${contextQuality.hasHighConfidenceRAG ? 'HIGH' : 'MEDIUM'}

Internal Database Context:
${dbContext || 'None'}

Wikipedia Context:
${wikiContext || 'None'}

User's Question:
"${rewrittenQuery}"

IMPORTANT: Base your answer ONLY on the context provided above. If information is missing, explicitly state what is needed.`;
}

async function generateStreamingResponse(context, sourceValidation, messages) {
    const disclaimer = generateConfidenceDisclaimer(context.contextQuality, sourceValidation);
    const enhancedContextInfo = `${disclaimer}\n\n${context.fullContext}\n\nIMPORTANT: Start your response with the confidence level and be explicit about limitations.`;
    const messagesForApi = [...messages.slice(0, -1), { role: 'user', content: enhancedContextInfo }];
    
    const response = await groq.chat.completions.create({
        model: GENERATION_MODEL,
        stream: true,
        messages: [{ role: 'system', content: getGeneratorPrompt(sourceValidation) }, ...messagesForApi],
    });

    const stream = OpenAIStream(response);
    return new StreamingTextResponse(stream, {
        headers: {
            'X-Confidence-Level': context.contextQuality.hasHighConfidenceRAG ? 'high' : 'medium',
            'X-Source-Validation': sourceValidation.reliability
        }
    });
}

async function generateInsufficientDataResponse(context, rewrittenQuery) {
     const insufficientDataResponse = INSUFFICIENT_DATA_PROMPT
        .replace('{question}', rewrittenQuery)
        .replace('{ragResults}', context.contextQuality.ragResultCount)
        .replace('{wikiResults}', context.contextQuality.wikiResultCount);
    
    const fallbackResponse = await groq.chat.completions.create({
        model: GENERATION_MODEL,
        messages: [{ role: 'user', content: insufficientDataResponse }],
        stream: true,
    });
    
    const stream = OpenAIStream(fallbackResponse);
    return new StreamingTextResponse(stream);
}

export async function generateFinalResponse({ context, sourceValidation, messages }) {
    if (!context.contextQuality.hasSufficientContext) {
        return generateInsufficientDataResponse(context, context.rewrittenQuery);
    }

    const fullContext = assembleContext(context.ragResults, context.wikiResults, context.rewrittenQuery, context.contextQuality, sourceValidation);
    const finalContext = { ...context, fullContext };
    
    // For now, we will always stream. The logic for non-streaming can be added later if needed.
    return generateStreamingResponse(finalContext, sourceValidation, messages);
}

# File: src/lib/rag/orchestrator.js
// src/lib/rag/orchestrator.js (version 1.0)
import { retrieveContextForQuery } from './retrieval';
import { assessContextQuality, crossValidateSources } from './validation';
import { generateFinalResponse } from './generation';

/**
 * Main orchestrator for the RAG chat pipeline.
 * @param {Array<object>} messages - The chat messages from the client.
 * @returns {Promise<StreamingTextResponse|Response>} The final response object for the API route.
 */
export async function processChatRequest(messages) {
    // 1. Retrieval Phase
    const context = await retrieveContextForQuery(messages);

    // 2. Validation & Quality Assessment Phase
    const contextQuality = assessContextQuality(context.ragResults, context.wikiResults);
    const sourceValidation = crossValidateSources(context.ragResults, context.wikiResults);
    
    const fullContext = { ...context, contextQuality };

    // 3. Generation Phase
    const finalResponse = await generateFinalResponse({
        context: fullContext,
        sourceValidation,
        messages
    });

    return finalResponse;
}

# File: src/lib/rag/prompts.js
// src/lib/rag/prompts.js (version 1.0)

export const QUERY_REWRITER_PROMPT = `You are a query rewriting expert. Your task is to take a conversation history and the latest user question, and rewrite the question into a single, standalone query that is optimal for a vector database search.

- If the latest question is already a complete, standalone question, use it as is.
- If the latest question is a follow-up (e.g., "what about him?", "and his wife?"), combine it with context from the history.
- The rewritten query should be concise and contain all the necessary keywords.

Example 1:
History:
"assistant: Bestseller was founded by Troels Holch Povlsen."
"user: What is his net worth?"
Rewritten Query: "What is Troels Holch Povlsen's net worth?"

Example 2:
History:
"user: Tell me about Bestseller."
"assistant: Bestseller is a fashion company..."
"user: Who founded it?"
Rewritten Query: "Who founded the Bestseller company?"

Respond ONLY with the rewritten query, with no extra text or quotes.`;

export const ENTITY_EXTRACTOR_PROMPT = `You are a highly intelligent entity extraction and disambiguation agent. Your task is to analyze the "User's Question" and identify the 1-2 most important proper nouns (people, companies, specific events).

CRITICAL INSTRUCTIONS:
1.  **Disambiguate the entity type.** If the entity is a company, append "(company)". If it is a person, append "(person)".
2.  Be precise and return only the essential search term.

Example 1:
User's Question: "Who founded Bestseller?"
Your Output: { "entities": ["Bestseller (company)"] }

Example 2:
User's Question: "Tell me about Troels Holch Povlsen"
Your Output: { "entities": ["Troels Holch Povlsen (person)"] }

Example 3:
User's Question: "What is the history of Nine United?"
Your Output: { "entities": ["Nine United (company)"] }

Respond ONLY with a valid JSON object: { "entities": ["Entity 1", "Entity 2"] }`;

export const getGeneratorPrompt = (sourceValidation) => `You are an elite intelligence analyst. Your primary directive is to synthesize ONLY the provided context to answer the "User's Question".

**CRITICAL RULES:**
1. You MUST ONLY use information explicitly provided in the context sources below
2. If you cannot answer the question with the provided context, say "I don't have enough information in my sources to answer this question"
3. NEVER add information from your general knowledge unless explicitly marked as inference
4. Be precise about what each source says - don't extrapolate beyond what's written
5. If sources conflict, acknowledge the conflict and present both perspectives

**SOURCE VALIDATION STATUS:**
- Cross-source validation: ${sourceValidation.reliability} reliability
- Detected conflicts: ${sourceValidation.conflicts.length}
- Confirmed facts: ${sourceValidation.confirmations.length}

**SOURCE HIERARCHY:**
1. **Internal Database Context** - Highest priority, treat as authoritative
2. **Wikipedia Context** - Secondary source for background
3. **Inference** - Only if you must connect obvious dots, mark clearly as inference

**OUTPUT FORMATTING:**
- Use <rag>fact</rag> for Internal Database information
- Use <wiki>fact</wiki> for Wikipedia information  
- Use <inference>logical connection</inference> for necessary inferences
- If sources conflict, acknowledge the conflict explicitly

**EXAMPLE GOOD RESPONSE:**
<rag>Anders Holch Povlsen's net worth is $7.8 billion according to Forbes 2023.</rag> <wiki>He owns Bestseller fashion company and is the largest private landowner in Scotland.</wiki> However, I don't have specific information about his current investment strategies in my sources.

**EXAMPLE BAD RESPONSE:**
He's probably investing in sustainable fashion because that's a trend among billionaires. (This adds unsourced speculation)`;

export const FACT_CHECKER_PROMPT = `You are a fact-checking agent. Review the proposed response and verify that:

1. All factual claims are supported by the provided sources
2. No unsourced information has been added
3. Any inferences are logical and clearly marked

Respond with JSON:
{
  "approved": boolean,
  "issues": ["list of specific problems if any"],
  "confidence_score": number (0-1),
  "recommendation": "approve/revise/insufficient_data"
}`;

export const INSUFFICIENT_DATA_PROMPT = `The user asked: "{question}"

Based on your search, you found:
- {ragResults} relevant documents in the internal database
- {wikiResults} Wikipedia articles

Generate a helpful response that:
1. Acknowledges what you searched for
2. Explains what information is missing
3. Suggests how they might find this information
4. Offers to help with related questions you CAN answer

Be specific about what you looked for and what would be needed to answer their question.`;

# File: src/lib/rag/retrieval.js
// src/lib/rag/retrieval.js (version 1.0)
import OpenAI from 'openai';
import { Pinecone } from '@pinecone-database/pinecone';
import { generateQueryEmbeddings } from '@/lib/embeddings';
import { fetchBatchWikipediaSummaries, validateWikipediaContent } from '@/lib/wikipedia';
import { QUERY_REWRITER_PROMPT, ENTITY_EXTRACTOR_PROMPT } from './prompts';

// --- Initialize Clients ---
if (!process.env.GROQ_API_KEY || !process.env.PINECONE_API_KEY) {
    throw new Error('Missing API keys in environment variables');
}
const groq = new OpenAI({ apiKey: process.env.GROQ_API_KEY, baseURL: 'https://api.groq.com/openai/v1' });
const pc = new Pinecone({ apiKey: process.env.PINECONE_API_KEY });
const pineconeIndex = pc.index(process.env.PINECONE_INDEX_NAME);

// --- Models & Config ---
const QUERY_REWRITER_MODEL = 'openai/gpt-oss-20b';
const ENTITY_EXTRACTOR_MODEL = 'openai/gpt-oss-120b';
const SIMILARITY_THRESHOLD = 0.38;

async function rewriteQuery(messages) {
    let queryForRetrieval = messages[messages.length - 1].content;
    if (messages.length > 1) {
        const conversationHistory = messages.slice(-5, -1).map(m => `${m.role}: ${m.content}`).join('\n');
        const rewriteResponse = await groq.chat.completions.create({
            model: QUERY_REWRITER_MODEL,
            messages: [{ role: 'system', content: QUERY_REWRITER_PROMPT }, { role: 'user', content: `History:\n${conversationHistory}\n\nLatest question: "${queryForRetrieval}"` }],
            temperature: 0.0
        });
        queryForRetrieval = rewriteResponse.choices[0].message.content.trim();
        console.log(`[Query Rewriter] Rewritten to: "${queryForRetrieval}"`);
    }
    return queryForRetrieval;
}

async function extractEntities(query) {
    const entityResponse = await groq.chat.completions.create({
        model: ENTITY_EXTRACTOR_MODEL,
        messages: [{ role: 'system', content: ENTITY_EXTRACTOR_PROMPT }, { role: 'user', content: `User's Question: "${query}"` }],
        response_format: { type: 'json_object' },
    });
    const { entities } = JSON.parse(entityResponse.choices[0].message.content);
    console.log(`[Entity Agent] Extracted & Disambiguated: ${entities.join(', ')}`);
    return entities;
}

async function fetchPineconeContext(query, entities) {
    const fullQueryEmbeddings = await generateQueryEmbeddings(query);
    const entityEmbeddings = entities.length > 0 ? await generateQueryEmbeddings(entities[0]) : [];
    const allQueryEmbeddings = [...fullQueryEmbeddings, ...entityEmbeddings];
    
    const pineconePromises = allQueryEmbeddings.map(embedding =>
        pineconeIndex.query({ topK: 3, vector: embedding, includeMetadata: true })
    );
    const pineconeResponses = await Promise.all(pineconePromises);
    
    const uniqueMatches = new Map();
    pineconeResponses.forEach(response => {
        response?.matches?.forEach(match => {
            if (!uniqueMatches.has(match.id) || match.score > uniqueMatches.get(match.id).score) {
                uniqueMatches.set(match.id, match);
            }
        });
    });
    
    return Array.from(uniqueMatches.values())
        .filter(match => match.score >= SIMILARITY_THRESHOLD)
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
}

async function fetchValidatedWikipediaContext(entities) {
    const wikiResults = await fetchBatchWikipediaSummaries(entities);
    const validWikiResults = [];
    for (const res of wikiResults.filter(r => r.success)) {
        const validation = await validateWikipediaContent(res.summary);
        if (validation.valid) {
            validWikiResults.push({ ...res, validation });
        }
    }
    return validWikiResults;
}

export async function retrieveContextForQuery(messages) {
    const rewrittenQuery = await rewriteQuery(messages);
    const entities = await extractEntities(rewrittenQuery);
    
    const [pineconeResults, wikipediaResults] = await Promise.all([
        fetchPineconeContext(rewrittenQuery, entities),
        fetchValidatedWikipediaContext(entities)
    ]);
    
    console.log(`[RAG] Found ${pineconeResults.length} relevant documents from Pinecone.`);
    console.log(`[Wikipedia] Found ${wikipediaResults.length} valid articles from Wikipedia.`);
    
    return {
        rewrittenQuery,
        entities,
        ragResults: pineconeResults,
        wikiResults: wikipediaResults
    };
}

# File: src/lib/rag/validation.js
// src/lib/rag/validation.js (version 1.0)

// --- Constants ---
const HIGH_CONFIDENCE_THRESHOLD = 0.75;
const SIMILARITY_THRESHOLD = 0.38;

// --- Helper Functions (Internal to this module) ---
function simpleEntityExtractor(text, sourceIdentifier) {
    const match = text.match(/([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)/);
    if (match) return [{ name: match[0], facts: [text] }];
    return [{ name: sourceIdentifier, facts: [text] }];
}

function extractEntitiesFromRAG(ragResults) {
    if (!ragResults) return [];
    return ragResults.flatMap(r => simpleEntityExtractor(r.metadata?.summary || '', r.metadata?.headline || 'RAG Source'));
}

function extractEntitiesFromWiki(wikiResults) {
    if (!wikiResults) return [];
    return wikiResults.flatMap(w => simpleEntityExtractor(w.summary || '', w.title || 'Wiki Source'));
}

function entitySimilarity(entityA, entityB) {
    const nameA = entityA.name.toLowerCase();
    const nameB = entityB.name.toLowerCase();
    if (nameA.includes(nameB) || nameB.includes(nameA)) return 0.9;
    return 0;
}

function factsConflict(factsA, factsB) {
    // Placeholder for a future NLI model implementation.
    return false;
}

// --- Exported Validation Functions ---

export function assessContextQuality(ragResults, wikiResults) {
    const ragScore = ragResults.length > 0 ? Math.max(...ragResults.map(r => r.score)) : 0;
    const highQualityWiki = wikiResults.filter(r => r.validation?.quality === 'high').length;
    const mediumQualityWiki = wikiResults.filter(r => r.validation?.quality === 'medium').length;
    const wikiScore = highQualityWiki > 0 ? 0.7 : (mediumQualityWiki > 0 ? 0.5 : 0);
    const combinedScore = Math.max(ragScore, wikiScore);

    return {
        hasHighConfidenceRAG: ragScore >= HIGH_CONFIDENCE_THRESHOLD,
        hasSufficientContext: combinedScore >= SIMILARITY_THRESHOLD,
        ragResultCount: ragResults.length,
        wikiResultCount: wikiResults.length,
        highQualityWikiCount: highQualityWiki,
        maxSimilarity: ragScore,
        combinedConfidence: combinedScore,
        hasMultipleSources: ragResults.length > 0 && wikiResults.length > 0,
        hasHighQualityContent: ragScore >= HIGH_CONFIDENCE_THRESHOLD || highQualityWiki > 0
    };
}

export function crossValidateSources(ragResults, wikiResults) {
    const validation = { conflicts: [], confirmations: [], reliability: 'unknown' };

    if (!ragResults || !wikiResults || ragResults.length === 0 || wikiResults.length === 0) {
        validation.reliability = 'single_source';
        return validation;
    }

    const ragEntities = extractEntitiesFromRAG(ragResults);
    const wikiEntities = extractEntitiesFromWiki(wikiResults);

    ragEntities.forEach(ragEntity => {
        const matchingWiki = wikiEntities.find(wiki => entitySimilarity(ragEntity, wiki) > 0.8);
        if (matchingWiki) {
            if (factsConflict(ragEntity.facts, matchingWiki.facts)) {
                validation.conflicts.push({ entity: ragEntity.name, ragFact: ragEntity.facts[0], wikiFact: matchingWiki.facts[0], severity: 'high' });
            } else {
                validation.confirmations.push({ entity: ragEntity.name, confirmedBy: 'both_sources' });
            }
        }
    });

    if (validation.conflicts.length > 0) validation.reliability = 'conflicting';
    else if (validation.confirmations.length > 0) validation.reliability = 'confirmed';
    else validation.reliability = 'unconfirmed';

    return validation;
}

export function detectHallucinations(responseText, sources) {
    const combinedSourceText = sources.map(s => s.metadata?.summary || s.summary || '').join(' ').toLowerCase();
    const sentences = responseText.split('.').filter(s => s.trim().length > 10);
    let supportedSentences = 0;

    if (combinedSourceText.length === 0 || sentences.length === 0) {
        return { confidenceScore: 0, recommendation: 'reject' };
    }

    sentences.forEach(sentence => {
        const keywords = sentence.toLowerCase().trim().split(' ').filter(w => w.length > 4);
        if (keywords.length === 0) {
            supportedSentences++;
            return;
        }
        const supportedKeywords = keywords.filter(k => combinedSourceText.includes(k));
        if ((supportedKeywords.length / keywords.length) > 0.5) {
            supportedSentences++;
        }
    });

    const confidenceScore = supportedSentences / sentences.length;
    return {
        confidenceScore,
        recommendation: confidenceScore > 0.6 ? 'approve' : 'reject'
    };
}

export function generateQualityReport({ contextQuality, validation, hallucinationReport, responseLength, sourceCount }) {
    let overallScore = 0;
    const weaknesses = [];

    overallScore += (contextQuality.combinedConfidence || 0) * 0.4;
    overallScore += (hallucinationReport.confidenceScore || 0) * 0.4;
    
    if (validation.reliability === 'confirmed') overallScore += 0.2;
    else if (validation.reliability === 'conflicting') {
        overallScore -= 0.3;
        weaknesses.push('Sources are conflicting.');
    }

    if (sourceCount === 0) {
        overallScore = 0;
        weaknesses.push('No sources found.');
    }

    overallScore = Math.max(0, Math.min(1, overallScore));
    return {
        overallScore,
        recommendation: overallScore > 0.55 ? 'approve' : 'reject',
        weaknesses,
    };
}

export function generateConfidenceDisclaimer(contextQuality, sourceValidation) {
    let disclaimer = 'Based on the available information';
    if (contextQuality.hasHighConfidenceRAG) disclaimer = 'Based on high-confidence internal documents';
    else if (contextQuality.hasSufficientContext) disclaimer = 'Based on a preliminary analysis of available documents';
    else return 'I could not find sufficient information to answer this question reliably.';

    if (sourceValidation.reliability === 'confirmed' && contextQuality.hasMultipleSources) disclaimer += ', which have been cross-validated from multiple sources.';
    else if (sourceValidation.reliability === 'conflicting') disclaimer += '. **Warning:** Some sources presented conflicting information, which may affect the accuracy of this summary.';
    else if (contextQuality.ragResultCount > 0 && contextQuality.wikiResultCount === 0) disclaimer += ', primarily from the internal database.';
    else if (contextQuality.ragResultCount === 0 && contextQuality.wikiResultCount > 0) disclaimer += ', primarily from Wikipedia.';
    
    return `> *${disclaimer}*`;
}

# File: src/lib/utils.js
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}


# File: src/lib/wikipedia.js
// src/lib/wikipedia.js (Enhanced version with better search, caching, and validation)
"use server";

const WIKI_API_ENDPOINT = "https://en.wikipedia.org/w/api.php";
const WIKI_SUMMARY_LENGTH = 1200; // Slightly increased for better context
const SEARCH_LIMIT = 3; // Search multiple candidates
const CACHE_TTL = 1000 * 60 * 30; // 30 minutes cache

// In-memory cache for Wikipedia results
const wikiCache = new Map();

/**
 * Cache management utilities
 */
function createWikiCacheKey(query) {
    return `wiki_${query.toLowerCase().trim().replace(/\s+/g, '_')}`;
}

function isValidCacheEntry(entry) {
    return entry && (Date.now() - entry.timestamp) < CACHE_TTL;
}

function cleanExpiredCache() {
    const now = Date.now();
    for (const [key, value] of wikiCache.entries()) {
        if (now - value.timestamp >= CACHE_TTL) {
            wikiCache.delete(key);
        }
    }
}

/**
 * Enhanced Wikipedia search with multiple strategies
 * @param {string} query - The search term
 * @returns {Promise<{success: boolean, title?: string, summary?: string, confidence?: number, error?: string}>}
 */
export async function fetchWikipediaSummary(query) {
    if (!query || query.trim().length === 0) {
        return { success: false, error: "Query cannot be empty" };
    }

    const cleanQuery = query.trim();
    const cacheKey = createWikiCacheKey(cleanQuery);
    
    // Check cache first
    if (wikiCache.has(cacheKey)) {
        const cached = wikiCache.get(cacheKey);
        if (isValidCacheEntry(cached)) {
            console.log(`[Wikipedia Cache] Hit for "${cleanQuery}"`);
            return cached.data;
        } else {
            wikiCache.delete(cacheKey);
        }
    }

    // Clean expired cache entries periodically
    if (Math.random() < 0.1) { // 10% chance
        cleanExpiredCache();
    }

    try {
        // Strategy 1: Try exact search first
        let result = await tryExactSearch(cleanQuery);
        
        // Strategy 2: If exact search fails, try fuzzy search
        if (!result.success) {
            result = await tryFuzzySearch(cleanQuery);
        }
        
        // Strategy 3: If still failing, try with common variations
        if (!result.success) {
            result = await trySearchVariations(cleanQuery);
        }

        // Cache the result (both success and failure to avoid repeated API calls)
        wikiCache.set(cacheKey, {
            data: result,
            timestamp: Date.now()
        });

        return result;

    } catch (error) {
        console.error(`[Wikipedia Client] Unexpected error for "${cleanQuery}": ${error.message}`);
        const errorResult = { success: false, error: `Unexpected error: ${error.message}` };
        
        // Cache failures too, but with shorter TTL
        wikiCache.set(cacheKey, {
            data: errorResult,
            timestamp: Date.now() - (CACHE_TTL * 0.8) // Expire sooner for errors
        });
        
        return errorResult;
    }
}

/**
 * Try exact search using opensearch API
 */
async function tryExactSearch(query) {
    try {
        const searchParams = new URLSearchParams({
            action: "opensearch",
            search: query,
            limit: "1",
            namespace: "0",
            format: "json",
        });

        const searchResponse = await fetch(`${WIKI_API_ENDPOINT}?${searchParams.toString()}`, {
            headers: { 'User-Agent': 'RAG-Chatbot/1.0' }
        });

        if (!searchResponse.ok) {
            throw new Error(`Search API returned status ${searchResponse.status}`);
        }

        const searchData = await searchResponse.json();
        const pageTitle = searchData[1]?.[0];

        if (!pageTitle) {
            return { success: false, error: `No exact match found for "${query}"` };
        }

        const summary = await fetchPageSummary(pageTitle);
        if (summary.success) {
            console.log(`[Wikipedia] Exact search success for "${query}" -> "${pageTitle}"`);
            return { ...summary, confidence: 0.9 };
        }
        
        return summary;
        
    } catch (error) {
        return { success: false, error: `Exact search failed: ${error.message}` };
    }
}

/**
 * Try fuzzy search using search API
 */
async function tryFuzzySearch(query) {
    try {
        const searchParams = new URLSearchParams({
            action: "query",
            list: "search",
            srsearch: query,
            srlimit: SEARCH_LIMIT,
            srnamespace: "0",
            format: "json",
        });

        const searchResponse = await fetch(`${WIKI_API_ENDPOINT}?${searchParams.toString()}`, {
            headers: { 'User-Agent': 'RAG-Chatbot/1.0' }
        });

        if (!searchResponse.ok) {
            throw new Error(`Fuzzy search API returned status ${searchResponse.status}`);
        }

        const searchData = await searchResponse.json();
        const searchResults = searchData.query?.search || [];

        if (searchResults.length === 0) {
            return { success: false, error: `No fuzzy search results found for "${query}"` };
        }

        // Try the best match first
        const bestMatch = searchResults[0];
        const summary = await fetchPageSummary(bestMatch.title);
        
        if (summary.success) {
            console.log(`[Wikipedia] Fuzzy search success for "${query}" -> "${bestMatch.title}"`);
            return { 
                ...summary, 
                confidence: Math.min(0.8, bestMatch.score / 100) // Use search score for confidence
            };
        }

        return summary;
        
    } catch (error) {
        return { success: false, error: `Fuzzy search failed: ${error.message}` };
    }
}

/**
 * Try search with common variations
 */
async function trySearchVariations(query) {
    const variations = generateSearchVariations(query);
    
    for (const variation of variations) {
        const result = await tryExactSearch(variation);
        if (result.success) {
            console.log(`[Wikipedia] Variation search success for "${query}" using "${variation}"`);
            return { ...result, confidence: 0.6 };
        }
    }
    
    return { success: false, error: `No results found for "${query}" or its variations` };
}

/**
 * Generate search variations for better matching
 */
function generateSearchVariations(query) {
    const variations = [];
    
    // Remove common business suffixes
    const businessSuffixes = [' Inc', ' LLC', ' Corp', ' Company', ' Ltd', ' AG', ' GmbH'];
    let baseQuery = query;
    
    for (const suffix of businessSuffixes) {
        if (baseQuery.endsWith(suffix)) {
            baseQuery = baseQuery.slice(0, -suffix.length);
            variations.push(baseQuery);
            break;
        }
    }
    
    // Add common variations
    if (!query.toLowerCase().includes('company')) {
        variations.push(`${query} company`);
    }
    
    // Try without parenthetical information
    const withoutParens = query.replace(/\s*\([^)]*\)/g, '');
    if (withoutParens !== query) {
        variations.push(withoutParens);
    }
    
    // Try first name only for person names
    const words = query.split(' ');
    if (words.length > 1 && words[0].match(/^[A-Z][a-z]+$/)) {
        variations.push(words[0]);
    }
    
    return variations.slice(0, 3); // Limit variations
}

/**
 * Fetch summary for a specific page title
 */
async function fetchPageSummary(pageTitle) {
    try {
        const summaryParams = new URLSearchParams({
            action: "query",
            prop: "extracts|pageprops",
            exintro: "true",
            explaintext: "true",
            titles: pageTitle,
            format: "json",
            redirects: "1",
        });

        const summaryResponse = await fetch(`${WIKI_API_ENDPOINT}?${summaryParams.toString()}`, {
            headers: { 'User-Agent': 'RAG-Chatbot/1.0' }
        });

        if (!summaryResponse.ok) {
            throw new Error(`Summary API returned status ${summaryResponse.status}`);
        }

        const summaryData = await summaryResponse.json();
        const pages = summaryData.query?.pages || {};
        const pageId = Object.keys(pages)[0];
        const page = pages[pageId];

        if (!page || page.missing) {
            return { success: false, error: `Page "${pageTitle}" does not exist` };
        }

        const extract = page.extract;
        if (!extract || extract.trim().length === 0) {
            return { success: false, error: `No summary content found for "${pageTitle}"` };
        }

        // Check if this might be a disambiguation page
        if (extract.toLowerCase().includes('may refer to:') || 
            extract.toLowerCase().includes('disambiguation')) {
            return { 
                success: false, 
                error: `"${pageTitle}" is a disambiguation page - need more specific query` 
            };
        }

        const summary = extract.length > WIKI_SUMMARY_LENGTH
            ? extract.substring(0, WIKI_SUMMARY_LENGTH) + '...'
            : extract;

        return { 
            success: true, 
            title: pageTitle, 
            summary,
            wordCount: extract.split(' ').length
        };

    } catch (error) {
        return { success: false, error: `Failed to fetch summary: ${error.message}` };
    }
}

/**
 * Batch fetch multiple Wikipedia summaries
 * @param {Array<string>} queries 
 * @returns {Promise<Array<Object>>}
 */
export async function fetchBatchWikipediaSummaries(queries) {
    if (!queries || queries.length === 0) {
        return [];
    }

    // Process with controlled concurrency to avoid overwhelming the API
    const BATCH_SIZE = 3;
    const results = [];

    for (let i = 0; i < queries.length; i += BATCH_SIZE) {
        const batch = queries.slice(i, i + BATCH_SIZE);
        const batchPromises = batch.map(query => 
            fetchWikipediaSummary(query).catch(error => ({
                success: false,
                error: error.message,
                query
            }))
        );

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);

        // Small delay between batches to be respectful to Wikipedia API
        if (i + BATCH_SIZE < queries.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    console.log(`[Wikipedia Batch] Processed ${queries.length} queries, ${results.filter(r => r.success).length} successful`);
    return results;
}

/**
 * Get cache statistics
 * @returns {Promise<Object>}
 */
export async function getWikipediaCacheStats() {
    const now = Date.now();
    let validEntries = 0;
    let expiredEntries = 0;

    for (const [key, value] of wikiCache.entries()) {
        if (now - value.timestamp < CACHE_TTL) {
            validEntries++;
        } else {
            expiredEntries++;
        }
    }

    return {
        totalEntries: wikiCache.size,
        validEntries,
        expiredEntries,
        cacheHitRate: validEntries / (validEntries + expiredEntries) || 0
    };
}

/**
 * Validate Wikipedia content quality
 * @param {string} summary 
 * @returns {Promise<Object>}
 */
export async function validateWikipediaContent(summary) {
    if (!summary) {
        return { valid: false, reason: 'Empty summary' };
    }

    const wordCount = summary.split(' ').length;
    if (wordCount < 10) {
        return { valid: false, reason: 'Summary too short' };
    }

    // Check for common Wikipedia stub indicators
    const stubIndicators = [
        'this article is a stub',
        'you can help wikipedia',
        'this biography of a living person',
        'citation needed'
    ];

    const hasStubIndicators = stubIndicators.some(indicator => 
        summary.toLowerCase().includes(indicator)
    );

    if (hasStubIndicators) {
        return { valid: false, reason: 'Stub or low-quality article' };
    }

    return { valid: true, wordCount, quality: wordCount > 100 ? 'high' : 'medium' };
}

# File: src/middleware.js
import { NextResponse } from 'next/server';

const COOKIE_NAME = 'headlines-auth';
const COOKIE_SECRET = process.env.COOKIE_SECRET || 'default-secret-for-dev-please-change-in-production';

export function middleware(request) {
    const { pathname } = request.nextUrl;
    
    // Log every request the middleware is running for.
    // This will show up in your `npm run dev` terminal.
    console.log(`[Middleware] Checking path: ${pathname}`);

    // Define paths that should NOT be protected by the password.
    const publicPaths = [
        '/login',
        // Add any other public paths here, e.g., '/about', '/privacy'
    ];

    // Check if the current path is one of the public paths.
    // We also exclude Next.js internal paths and API routes.
    if (
        publicPaths.includes(pathname) || 
        pathname.startsWith('/_next/') || 
        pathname.startsWith('/api/') ||
        pathname.includes('/favicon.ico')
    ) {
        // If it's a public path, do nothing and let the request continue.
        console.log(`[Middleware] Path is public. Allowing access.`);
        return NextResponse.next();
    }
    
    // --- If the path is NOT public, proceed with authentication check ---
    
    const authCookie = request.cookies.get(COOKIE_NAME);
    const isAuthenticated = authCookie && authCookie.value === COOKIE_SECRET;

    if (isAuthenticated) {
        // User has the correct cookie. Allow them to proceed to the protected page.
        console.log(`[Middleware] User is authenticated. Allowing access.`);
        return NextResponse.next();
    }

    // User is not authenticated. Redirect them to the login page.
    console.log(`[Middleware] User is NOT authenticated. Redirecting to /login.`);
    const loginUrl = new URL('/login', request.url);
    return NextResponse.redirect(loginUrl);
}

// A simple, broad matcher to ensure the middleware runs on EVERY request.
// The logic inside the function will then decide which paths are public.
export const config = {
  matcher: '/:path*',
};

# File: src/models/Article.js
// src/models/Article.js (version 2.2)
import mongoose from 'mongoose';

const { Schema, model, models } = mongoose;

const ArticleSchema = new Schema(
  {
    headline: {
      type: String,
      required: true,
      trim: true,
      minlength: 10,
      maxlength: 500,
    },
    headline_en: { type: String, required: false, trim: true },
    link: { type: String, required: true, unique: true, trim: true },
    newspaper: { type: String, required: true, trim: true },
    source: { type: String, required: true, trim: true },
    country: { type: String, required: false, trim: true, index: true },
    headline_selector: { type: String, required: false, trim: true },
    section: { type: String, required: false, trim: true },
    author: { type: String, required: false, trim: true },
    published: { type: String, required: false, trim: true },
    position: { type: String, required: false, trim: true },
    raw: { type: Schema.Types.Mixed, required: false },
    relevance_headline: { type: Number, required: true, min: 0, max: 100 },
    assessment_headline: { type: String, required: true, trim: true },
    articleContent: {
      headlines: { type: [String], required: false, default: [] },
      subheadings: { type: [String], required: false, default: [] },
      captions: { type: [String], required: false, default: [] },
      contents: { type: [String], required: false, default: [] },
    },
    topic: { type: String, required: false, trim: true },
    relevance_article: { type: Number, required: false, min: 0, max: 100 },
    assessment_article: { type: String, required: false, trim: true },
    amount: { type: Number, required: false },
    key_individuals: [{
        name: String,
        role_in_event: String,
        company: String,
        email_suggestion: { type: String, required: false },
    }],
    background: { type: String, required: false, trim: true },
    error: { type: String, required: false, trim: true, default: null },
    enrichment_error: { type: String, required: false, trim: true, default: null },
    storage_error_initial_headline_data: { type: String, required: false, trim: true, default: null },
    db_operation_status: { type: String, required: false, trim: true },
    db_error_reason: { type: String, required: false, trim: true },
    emailed: { type: Boolean, default: false },
    email_error: { type: String, required: false, trim: true, default: null },
    email_skipped_reason: { type: String, required: false, trim: true, default: null },
    embedding: { type: [Number], required: false },
  },
  {
    timestamps: true,
    collection: 'articles',
  }
);

ArticleSchema.index({ headline: 1 });
ArticleSchema.index({ newspaper: 1, createdAt: -1 });
ArticleSchema.index({ relevance_article: -1, createdAt: -1 });
ArticleSchema.index({ relevance_headline: -1, createdAt: -1 });
ArticleSchema.index({ country: 1, createdAt: -1 });

export default models.Article || model('Article', ArticleSchema);

# File: src/models/PushSubscription.js
// src/models/PushSubscription.js (version 1.1)
import mongoose from 'mongoose';

const { Schema, model, models } = mongoose;

const PushSubscriptionSchema = new Schema(
  {
    endpoint: { type: String, required: true, unique: true },
    keys: {
      p256dh: { type: String, required: true },
      auth: { type: String, required: true },
    },
  },
  {
    timestamps: true,
    collection: 'push_subscriptions',
  }
);

export default models.PushSubscription || model('PushSubscription', PushSubscriptionSchema);

# File: src/models/SynthesizedEvent.js
// src/models/SynthesizedEvent.js (version 2.0)
import mongoose from 'mongoose';

const { Schema, model, models } = mongoose;

const SourceArticleSchema = new Schema({
  headline: { type: String, required: true },
  link: { type: String, required: true },
  newspaper: { type: String, required: true },
}, { _id: false });

const KeyIndividualSchema = new Schema({
    name: String,
    role_in_event: String,
    company: String,
    email_suggestion: { type: String, required: false },
}, { _id: false });

const SynthesizedEventSchema = new Schema(
  {
    event_key: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      index: true,
      description: "A unique key for the event, e.g., 'acquisition-visma-innovateai-2024-05-20'",
    },
    synthesized_headline: { type: String, required: true, trim: true },
    synthesized_summary: { type: String, required: true, trim: true },
    ai_assessment_reason: { type: String, required: false },
    country: { type: String, required: true, index: true },
    source_articles: { type: [SourceArticleSchema], required: true },
    highest_relevance_score: { type: Number, required: true },
    key_individuals: { type: [KeyIndividualSchema], required: true },
    event_date: { type: Date, default: Date.now },
    emailed: { type: Boolean, default: false },
    email_sent_at: { type: Date },
  },
  {
    timestamps: true,
    collection: 'synthesized_events',
  }
);

SynthesizedEventSchema.index({ event_date: -1 });
SynthesizedEventSchema.index({ country: 1, createdAt: -1 });

export default models.SynthesizedEvent || model('SynthesizedEvent', SynthesizedEventSchema);

# File: src/store/use-app-store.js
// src/store/use-app-store.js (version 1.0)
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

export const useAppStore = create(
  persist(
    (set, get) => ({
      // State
      chats: [],
      activeChatId: null,
      allMessages: {},
      chatContextPrompt: '',

      // Actions
      setChatContextPrompt: (prompt) => set({ chatContextPrompt: prompt }),

      createChat: () => {
        const newChatId = `chat_${Date.now()}`;
        const newChat = {
          id: newChatId,
          title: 'New Chat',
          createdAt: new Date().toISOString()
        };
        
        set(state => ({
          chats: [newChat, ...state.chats],
          activeChatId: newChatId,
          allMessages: { ...state.allMessages, [newChatId]: [] }
        }));
        
        return newChatId;
      },

      selectChat: (id) => {
        const { chats } = get();
        if (chats.find(c => c.id === id)) {
            set({ activeChatId: id });
        } else if (chats.length > 0) {
            set({ activeChatId: chats[0].id });
        } else {
            // If no chats exist, create one
            get().createChat();
        }
      },
      
      updateChatTitle: (id, newTitle) => {
        set(state => ({
          chats: state.chats.map(chat =>
            chat.id === id ? { ...chat, title: newTitle } : chat
          )
        }));
      },
      
      getMessagesForChat: (id) => {
        return get().allMessages[id] || [];
      },
      
      setMessagesForChat: (id, messages) => {
        set(state => ({
          allMessages: { ...state.allMessages, [id]: messages }
        }));
      },
      
      // Initialization logic to ensure an active chat always exists
      init: () => {
        const { chats, activeChatId } = get();
        if (chats.length === 0) {
          get().createChat();
        } else if (!activeChatId || !chats.find(c => c.id === activeChatId)) {
          set({ activeChatId: chats[0].id });
        }
      }
    }),
    {
      name: 'headlines-app-storage',
      storage: createJSONStorage(() => localStorage),
      // Only persist a subset of the state
      partialize: (state) => ({
        chats: state.chats,
        activeChatId: state.activeChatId,
        allMessages: state.allMessages,
      }),
    }
  )
);

# File: tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './src/app/**/*.{js,jsx}',
    './src/components/**/*.{js,jsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: { /* ... (no changes here) ... */ },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      fontFamily: {
        sans: ["var(--font-sans)", "sans-serif"],
        serif: ["Merriweather", "serif"],
      },
      // --- NEW: Custom Animations for Magical Login ---
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "fade-in-up": {
          "0%": { opacity: "0", transform: "translateY(10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
        "shake": {
          "0%, 100%": { transform: "translateX(0)" },
          "20%, 60%": { transform: "translateX(-5px)" },
          "40%, 80%": { transform: "translateX(5px)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "fade-in-up": "fade-in-up 0.5s ease-out forwards",
        "shake": "shake 0.5s ease-in-out",
      },
      // --- END NEW ---
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require('@tailwindcss/typography'),
  ],
}

# File: worker/index.js
// worker/index.js (version 1.2)
// The invalid `"use client";` directive has been removed.

self.addEventListener('push', (event) => {
  console.log('[Service Worker] Push Received.');
  console.log(`[Service Worker] Push had this data: "${event.data.text()}"`);

  let data;
  try {
    data = event.data.json();
  } catch (e) {
    console.error('[Service Worker] Failed to parse push data as JSON.');
    data = {
      title: 'New Update',
      body: event.data.text(),
      url: '/',
    };
  }

  const title = data.title || 'New Intelligence Alert';
  const options = {
    body: data.body || 'New content has been added.',
    icon: data.icon || '/icons/icon-192x192.png',
    badge: '/icons/icon-96x96.png',
    vibrate: [100, 50, 100],
    data: {
      url: data.url || '/',
    },
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', (event) => {
  console.log('[Service Worker] Notification click Received.');
  event.notification.close();
  const urlToOpen = new URL(event.notification.data.url, self.location.origin).href;

  event.waitUntil(
    self.clients.matchAll({
      type: 'window',
      includeUncontrolled: true,
    }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus().then(c => c.navigate(urlToOpen));
      }
      return self.clients.openWindow(urlToOpen);
    })
  );
});
